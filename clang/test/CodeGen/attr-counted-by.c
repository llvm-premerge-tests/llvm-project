// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 3
// RUN: %clang_cc1 -triple x86_64-unknown-linux-gnu -O2 -Wall -fsanitize=array-bounds,object-size,local-bounds -fstrict-flex-arrays=3 -emit-llvm -o - %s | FileCheck %s

#define __counted_by(member)    __attribute__((__counted_by__(member)))

typedef long unsigned int size_t;

struct annotated {
  unsigned long flags;
  int count;
  int array[] __counted_by(count);
};

extern void *malloc(size_t __size) __attribute__((__nothrow__)) __attribute__((__malloc__)) __attribute__((__warn_unused_result__));
extern void func(size_t);

// CHECK-LABEL: define dso_local void @test1(
// CHECK-SAME: ptr noundef [[P:%.*]], i32 noundef [[INDEX:%.*]], i32 noundef [[VAL:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[COUNT:%.*]] = getelementptr inbounds [[STRUCT_ANNOTATED:%.*]], ptr [[P]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[COUNT]], align 8, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = sext i32 [[INDEX]] to i64, !nosanitize !6
// CHECK-NEXT:    [[TMP2:%.*]] = zext i32 [[TMP0]] to i64, !nosanitize !6
// CHECK-NEXT:    [[TMP3:%.*]] = icmp ult i64 [[TMP1]], [[TMP2]], !nosanitize !6
// CHECK-NEXT:    br i1 [[TMP3]], label [[CONT7:%.*]], label [[HANDLER_OUT_OF_BOUNDS:%.*]], !prof [[PROF7:![0-9]+]], !nosanitize !6
// CHECK:       handler.out_of_bounds:
// CHECK-NEXT:    [[TMP4:%.*]] = zext i32 [[INDEX]] to i64, !nosanitize !6
// CHECK-NEXT:    tail call void @__ubsan_handle_out_of_bounds_abort(ptr nonnull @[[GLOB2:[0-9]+]], i64 [[TMP4]]) #[[ATTR4:[0-9]+]], !nosanitize !6
// CHECK-NEXT:    unreachable, !nosanitize !6
// CHECK:       cont7:
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [[STRUCT_ANNOTATED]], ptr [[P]], i64 0, i32 2, i64 [[TMP1]]
// CHECK-NEXT:    store i32 [[VAL]], ptr [[ARRAYIDX]], align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret void
//
void test1(struct annotated *p, int index, int val) {
  p->array[index] = val;
}

// CHECK-LABEL: define dso_local void @test2(
// CHECK-SAME: ptr noundef [[P:%.*]]) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[COUNT:%.*]] = getelementptr inbounds [[STRUCT_ANNOTATED:%.*]], ptr [[P]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[COUNT]], align 8, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP1:%.*]] = shl i32 [[TMP0]], 2
// CHECK-NEXT:    [[TMP2:%.*]] = zext i32 [[TMP1]] to i64
// CHECK-NEXT:    tail call void @func(i64 noundef [[TMP2]]) #[[ATTR5:[0-9]+]]
// CHECK-NEXT:    ret void
//
void test2(struct annotated *p) {
  func(__builtin_dynamic_object_size(p->array, 1));
}

volatile int vcount = 0; /* Prevents constant propagation */

// CHECK-LABEL: define dso_local void @test3(
// CHECK-SAME: ) local_unnamed_addr #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load volatile i32, ptr @vcount, align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 42
// CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[ADD]] to i64
// CHECK-NEXT:    [[MUL:%.*]] = shl nsw i64 [[CONV]], 2
// CHECK-NEXT:    [[ADD1:%.*]] = add nsw i64 [[MUL]], 16
// CHECK-NEXT:    [[TMP1:%.*]] = load volatile i32, ptr @vcount, align 4, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[TMP2:%.*]] = icmp ult i64 [[ADD1]], 8
// CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i32 [[ADD]], -2
// CHECK-NEXT:    [[TMP4:%.*]] = or i1 [[TMP2]], [[TMP3]]
// CHECK-NEXT:    br i1 [[TMP4]], label [[TRAP:%.*]], label [[TMP5:%.*]]
// CHECK:       5:
// CHECK-NEXT:    tail call void @func(i64 noundef [[ADD1]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
// CHECK:       trap:
// CHECK-NEXT:    tail call void @llvm.trap() #[[ATTR4]]
// CHECK-NEXT:    unreachable
//
void test3(void) {
  struct annotated *p = malloc(sizeof(*p) + (42 + vcount) * sizeof(*p->array));

  p->count = 42 + vcount;
  func(__builtin_dynamic_object_size(p, 1));
}
