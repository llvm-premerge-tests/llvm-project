// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -O3 -triple %itanium_abi_triple -emit-llvm -o - %s | FileCheck %s

// Is FP_CONTRACT honored in a simple case?
// CHECK-LABEL: @_Z13fp_contract_1fff(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call contract float @llvm.fmuladd.f32(float [[A:%.*]], float [[B:%.*]], float [[C:%.*]])
// CHECK-NEXT:    ret float [[TMP0]]
//
float fp_contract_1(float a, float b, float c) {
#pragma clang fp contract(fast)
  return a * b + c;
}

// Is FP_CONTRACT state cleared on exiting compound statements?
// CHECK-LABEL: @_Z13fp_contract_2fff(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MUL:%.*]] = fmul float [[A:%.*]], [[B:%.*]]
// CHECK-NEXT:    [[ADD:%.*]] = fadd float [[MUL]], [[C:%.*]]
// CHECK-NEXT:    ret float [[ADD]]
//
float fp_contract_2(float a, float b, float c) {
  {
#pragma clang fp contract(fast)
  }
  return a * b + c;
}

// Does FP_CONTRACT survive template instantiation?
class Foo {};
Foo operator+(Foo, Foo);

template <typename T>
T template_muladd(T a, T b, T c) {
#pragma clang fp contract(fast)
  return a * b + c;
}

// CHECK-LABEL: @_Z13fp_contract_3fff(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call contract float @llvm.fmuladd.f32(float [[A:%.*]], float [[B:%.*]], float [[C:%.*]])
// CHECK-NEXT:    ret float [[TMP0]]
//
float fp_contract_3(float a, float b, float c) {
  return template_muladd<float>(a, b, c);
}

template <typename T>
class fp_contract_4 {
  float method(float a, float b, float c) {
#pragma clang fp contract(fast)
    return a * b + c;
  }
};

// CHECK-LABEL: @_ZN13fp_contract_4IiE6methodEfff(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call contract float @llvm.fmuladd.f32(float [[A:%.*]], float [[B:%.*]], float [[C:%.*]])
// CHECK-NEXT:    ret float [[TMP0]]
//
template class fp_contract_4<int>;

// Check file-scoped FP_CONTRACT
#pragma clang fp contract(fast)
// CHECK-LABEL: @_Z13fp_contract_5fff(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call contract float @llvm.fmuladd.f32(float [[A:%.*]], float [[B:%.*]], float [[C:%.*]])
// CHECK-NEXT:    ret float [[TMP0]]
//
float fp_contract_5(float a, float b, float c) {
  return a * b + c;
}

// Verify that we can handle multiple flags on the same pragma
#pragma clang fp contract(fast) contract(off)
// CHECK-LABEL: @_Z13fp_contract_6fff(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MUL:%.*]] = fmul float [[A:%.*]], [[B:%.*]]
// CHECK-NEXT:    [[ADD:%.*]] = fadd float [[MUL]], [[C:%.*]]
// CHECK-NEXT:    ret float [[ADD]]
//
float fp_contract_6(float a, float b, float c) {
  return a * b + c;
}
