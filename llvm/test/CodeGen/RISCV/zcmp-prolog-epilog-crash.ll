; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -mattr=+zcmp -verify-machineinstrs  \
; RUN: -mtriple=riscv32 -target-abi ilp32 < %s \
; RUN: | FileCheck %s -check-prefixes=RV32IZCMP
; RUN: llc -mattr=+zcmp -verify-machineinstrs  \
; RUN: -mtriple=riscv64 -target-abi lp64 < %s  \
; RUN: | FileCheck %s -check-prefixes=RV64IZCMP

; This source code exposed a crash in RISC-V RISCVFrameLowering when executing
; the Prologue/Epilogue Insertion & Frame Finalization pass. The root cause was:
; Not doing a bounds check before using a returned iterator.
; NOTE: -mattr=+zcmp is essential to the reproducibility of the issue.

declare void @f1() nounwind

@x = external dso_local global i1, align 4
@y = external dso_local global i1, align 4
@a = external dso_local global i32, align 4
@b = external dso_local global i32, align 4
@c = external dso_local global i32, align 4
@d = external dso_local global i32, align 4

define void @f0() nounwind {
; RV32IZCMP-LABEL: f0:
; RV32IZCMP:       # %bb.0: # %entry
; RV32IZCMP-NEXT:    lui a0, %hi(x)
; RV32IZCMP-NEXT:    lbu a0, %lo(x)(a0)
; RV32IZCMP-NEXT:    beqz a0, .LBB0_2
; RV32IZCMP-NEXT:  .LBB0_1: # %cleanup
; RV32IZCMP-NEXT:    ret
; RV32IZCMP-NEXT:  .LBB0_2: # %if.end
; RV32IZCMP-NEXT:    lui a0, %hi(y)
; RV32IZCMP-NEXT:    lbu a0, %lo(y)(a0)
; RV32IZCMP-NEXT:    beqz a0, .LBB0_6
; RV32IZCMP-NEXT:  # %bb.3: # %if.end3
; RV32IZCMP-NEXT:    lui a0, %hi(a)
; RV32IZCMP-NEXT:    lui a1, %hi(b)
; RV32IZCMP-NEXT:    lui a2, 912092
; RV32IZCMP-NEXT:  .LBB0_4: # %for.cond
; RV32IZCMP-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32IZCMP-NEXT:    lw a3, %lo(a)(a0)
; RV32IZCMP-NEXT:    lw a4, %lo(b)(a1)
; RV32IZCMP-NEXT:    bge a3, a4, .LBB0_1
; RV32IZCMP-NEXT:  # %bb.5: # %for.body
; RV32IZCMP-NEXT:    # in Loop: Header=BB0_4 Depth=1
; RV32IZCMP-NEXT:    sw zero, -273(a2)
; RV32IZCMP-NEXT:    j .LBB0_4
; RV32IZCMP-NEXT:  .LBB0_6: # %if.then2
; RV32IZCMP-NEXT:    tail f1@plt
;
; RV64IZCMP-LABEL: f0:
; RV64IZCMP:       # %bb.0: # %entry
; RV64IZCMP-NEXT:    lui a0, %hi(x)
; RV64IZCMP-NEXT:    lbu a0, %lo(x)(a0)
; RV64IZCMP-NEXT:    beqz a0, .LBB0_2
; RV64IZCMP-NEXT:  .LBB0_1: # %cleanup
; RV64IZCMP-NEXT:    ret
; RV64IZCMP-NEXT:  .LBB0_2: # %if.end
; RV64IZCMP-NEXT:    lui a0, %hi(y)
; RV64IZCMP-NEXT:    lbu a0, %lo(y)(a0)
; RV64IZCMP-NEXT:    beqz a0, .LBB0_6
; RV64IZCMP-NEXT:  # %bb.3: # %if.end3
; RV64IZCMP-NEXT:    lui a0, %hi(a)
; RV64IZCMP-NEXT:    lui a1, %hi(b)
; RV64IZCMP-NEXT:    lui a2, 228023
; RV64IZCMP-NEXT:    slli a2, a2, 2
; RV64IZCMP-NEXT:  .LBB0_4: # %for.cond
; RV64IZCMP-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64IZCMP-NEXT:    lw a3, %lo(a)(a0)
; RV64IZCMP-NEXT:    lw a4, %lo(b)(a1)
; RV64IZCMP-NEXT:    bge a3, a4, .LBB0_1
; RV64IZCMP-NEXT:  # %bb.5: # %for.body
; RV64IZCMP-NEXT:    # in Loop: Header=BB0_4 Depth=1
; RV64IZCMP-NEXT:    sw zero, -273(a2)
; RV64IZCMP-NEXT:    j .LBB0_4
; RV64IZCMP-NEXT:  .LBB0_6: # %if.then2
; RV64IZCMP-NEXT:    tail f1@plt
entry:
  %0 = load i1, ptr @x, align 4
  br i1 %0, label %cleanup, label %if.end

if.end:
  %1 = load i1, ptr @y, align 4
  br i1 %1, label %if.end3, label %if.then2

if.then2:
  tail call void @f1()
  br label %cleanup

if.end3:
  br label %for.cond

for.cond:
  %2 = load i32, ptr @a, align 4
  %3 = load i32, ptr @b, align 4
  %cmp6 = icmp slt i32 %2, %3
  br i1 %cmp6, label %for.body, label %for.cond8

for.body:
  store i32 0, ptr inttoptr (i32 -559038737 to ptr), align 4
  br label %for.cond

for.cond8:
  %4 = load i32, ptr @c, align 4
  %5 = load i32, ptr @d, align 4
  %cmp10 = icmp slt i32 %4, %5
  br label %cleanup

cleanup:
  ret void
}

