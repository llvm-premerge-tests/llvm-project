; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -mtriple=aarch64-linux-gnu -mattr=+sme -aarch64-sme-abi %s | FileCheck %s
; RUN: opt -S -mtriple=aarch64-linux-gnu -mattr=+sme -aarch64-sme-abi -aarch64-sme-abi %s | FileCheck %s

declare void @foo_shared() "aarch64_pstate_za_shared"
declare void @bar_shared() "aarch64_pstate_za_shared"
declare void @fizz_shared() "aarch64_pstate_za_shared"
declare void @buzz_shared() "aarch64_pstate_za_shared"

declare void @snap_new() "aarch64_pstate_za_new"

declare i32 @normal_callee()

@except = external constant ptr
@invalid_argument = external constant ptr
@overflow_error = external constant ptr
@runtime_error = external constant ptr

; Try/Catch with one invoke of a private ZA function.
; Lazy-save must be set up for the invoke and for the private callee.

define i32 @private_za_invoke() "aarch64_pstate_za_shared" "aarch64_pstate_sm_enabled" personality i32 1 {
; CHECK-LABEL: @private_za_invoke(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @normal_callee()
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[LPAD:%.*]]
; CHECK:       lpad:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    call void @llvm.aarch64.sme.invoke.resume.pstatesm(i64 1)
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[RETURN]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ 23, [[LPAD]] ], [ 15, [[CHECK_ZA]] ], [ 15, [[RESTORE_ZA]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    ret i32 [[RETVAL]]
;
entry:
  invoke void @normal_callee() to label %return unwind label %lpad

lpad:
  %0 = landingpad { ptr, i32 }
  catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  %2 = tail call ptr @__cxa_begin_catch(ptr %1)
  tail call void @__cxa_end_catch()
  br label %return

return:
  %retval = phi i32 [ 23, %lpad ], [ 15, %entry ]
  ret i32 %retval
}

; Try/Catch with one invoke of a new ZA function.

define i32 @new_za_invoke() "aarch64_pstate_za_shared" "aarch64_pstate_sm_compatible" personality i32 1 {
; CHECK-LABEL: @new_za_invoke(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call aarch64_sme_preservemost_from_x2 [[TMP0]] @__arm_sme_state()
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue [[TMP0]] [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = and i64 [[TMP1]], 1
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    invoke void @snap_new()
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[LPAD:%.*]]
; CHECK:       lpad:
; CHECK-NEXT:    [[TMP3:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    call void @llvm.aarch64.sme.invoke.resume.pstatesm(i64 [[TMP2]])
; CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, i32 } [[TMP3]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP4]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[RETURN:%.*]]
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[RETURN]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ 23, [[LPAD]] ], [ 15, [[CHECK_ZA]] ], [ 15, [[RESTORE_ZA]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    ret i32 [[RETVAL]]
;
entry:
  invoke void @snap_new() to label %return unwind label %lpad

lpad:
  %0 = landingpad { ptr, i32 }
  catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  %2 = tail call ptr @__cxa_begin_catch(ptr %1)
  tail call void @__cxa_end_catch()
  br label %return

return:
  %retval = phi i32 [ 23, %lpad ], [ 15, %entry ]
  ret i32 %retval
}

; Try/Catch with one invoke of a shared ZA function and a private ZA call in the
; (unconditional) catch block.

; int unconditional() {
;   try {
;     foo();
;   } catch (...) {
;     normal_callee();
;     return 23;
;   }
;   return 15;
; }

define i32 @private_za_in_catch_block() "aarch64_pstate_za_shared" personality i32 1 {
; CHECK-LABEL: @private_za_in_catch_block(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @foo_shared()
; CHECK-NEXT:    to label [[RETURN:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    call void @normal_callee()
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ 23, [[LPAD1]] ], [ 15, [[ENTRY:%.*]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    ret i32 [[RETVAL]]
;
entry:
  invoke void @foo_shared() to label %return unwind label %lpad1

lpad1:
  %0 = landingpad { ptr, i32 }
  catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  %2 = tail call ptr @__cxa_begin_catch(ptr %1)
  call void @normal_callee()
  tail call void @__cxa_end_catch()
  br label %return

return:
  %retval = phi i32 [ 23, %lpad1 ], [ 15, %entry ]
  ret i32 %retval
}

; Try/Catch with one invoke of a shared ZA function and a private ZA call in the
; (unconditional) catch block.

; int unconditional() {
;   try {
;     foo();
;   } catch (...) {
;     normal_callee();
;     return 23;
;   }
;   return 15;
; }

define i32 @private_za_in_catch_block_from_new_za() "aarch64_pstate_za_new" personality i32 1 {
; CHECK-LABEL: @private_za_in_catch_block_from_new_za(
; CHECK-NEXT:  prelude:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[SAVE_ZA:%.*]], label [[ENTRY:%.*]]
; CHECK:       save.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    br label [[ENTRY]]
; CHECK:       entry:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @foo_shared()
; CHECK-NEXT:    to label [[RETURN:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    call void @normal_callee()
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ 23, [[LPAD1]] ], [ 15, [[ENTRY]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    ret i32 [[RETVAL]]
;
entry:
  invoke void @foo_shared() to label %return unwind label %lpad1

lpad1:
  %0 = landingpad { ptr, i32 }
  catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  %2 = tail call ptr @__cxa_begin_catch(ptr %1)
  call void @normal_callee()
  tail call void @__cxa_end_catch()
  br label %return

return:
  %retval = phi i32 [ 23, %lpad1 ], [ 15, %entry ]
  ret i32 %retval
}


;
; Try/Catch with one catch clause. Set up & restore lazy-save
;
; void except_func() {
;   try {
;      foo();
;   } catch (const std::invalid_argument& e) {
;      bar();
;   }
;   fizz();
; }

define void @call_after_catch_block() "aarch64_pstate_za_shared" personality i32 0 {
; CHECK-LABEL: @call_after_catch_block(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @foo_shared()
; CHECK-NEXT:    to label [[TRY_CONT:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr @invalid_argument
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = tail call i32 @llvm.eh.typeid.for(ptr nonnull @invalid_argument)
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    br i1 [[MATCHES]], label [[CATCH:%.*]], label [[EH_RESUME:%.*]]
; CHECK:       catch:
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP4:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP3]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[LIVE1:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC2:%.*]] = trunc i64 [[LIVE1]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE3:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC2]], ptr [[TPIDR2_OBJ_LIVE3]], align 2
; CHECK-NEXT:    [[TPI_INT4:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT4]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @bar_shared()
; CHECK-NEXT:    to label [[INVOKE_CONT:%.*]] unwind label [[LPAD2:%.*]]
; CHECK:       invoke.cont:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[TRY_CONT]]
; CHECK:       try.cont:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    tail call void @fizz_shared()
; CHECK-NEXT:    ret void
; CHECK:       lpad2:
; CHECK-NEXT:    [[TMP5:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    cleanup
; CHECK-NEXT:    [[LIVE5:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC6:%.*]] = trunc i64 [[LIVE5]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE7:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC6]], ptr [[TPIDR2_OBJ_LIVE7]], align 2
; CHECK-NEXT:    [[TPI_INT8:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT8]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[EH_RESUME]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_RESUME]]
; CHECK:       eh.resume:
; CHECK-NEXT:    [[LPAD_VAL6_MERGED:%.*]] = phi { ptr, i32 } [ [[TMP0]], [[LPAD1]] ], [ [[TMP5]], [[CHECK_ZA]] ], [ [[TMP5]], [[RESTORE_ZA]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    resume { ptr, i32 } [[LPAD_VAL6_MERGED]]
; CHECK:       terminate.lpad:
; CHECK-NEXT:    [[TMP6:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, i32 } [[TMP6]], 0
; CHECK-NEXT:    tail call void @__clang_call_terminate(ptr [[TMP7]])
; CHECK-NEXT:    unreachable
;

entry:
  invoke void @foo_shared() to label %try.cont unwind label %lpad1

lpad1:
  %0 = landingpad { ptr, i32 } catch ptr @invalid_argument
  %1 = extractvalue { ptr, i32 } %0, 1
  %2 = tail call i32 @llvm.eh.typeid.for(ptr nonnull @invalid_argument)
  %matches = icmp eq i32 %1, %2
  br i1 %matches, label %catch, label %eh.resume

catch:
  %3 = extractvalue { ptr, i32 } %0, 0
  %4 = tail call ptr @__cxa_begin_catch(ptr %3)
  invoke void @bar_shared() to label %invoke.cont unwind label %lpad2

invoke.cont:
  tail call void @__cxa_end_catch()
  br label %try.cont

try.cont:
  tail call void @fizz_shared()
  ret void

lpad2:
  %5 = landingpad { ptr, i32 } cleanup
  invoke void @__cxa_end_catch() to label %eh.resume unwind label %terminate.lpad

eh.resume:
  %lpad.val6.merged = phi { ptr, i32 } [ %0, %lpad1 ], [ %5, %lpad2 ]
  resume { ptr, i32 } %lpad.val6.merged

terminate.lpad:
  %6 = landingpad { ptr, i32 } catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  tail call void @__clang_call_terminate(ptr %7)
  unreachable
}

;
; Try/Catch with two catch clauses. Set up & restore lazy-save
;
; int multiple_catch() {
;   try {
;     foo();
;   } catch (const std::overflow_error& e) {
;     bar();
;   } catch (const std::runtime_error& e) {
;     fizz();
;     return 23;
;   }
;   return 42;
; }

define i32 @multiple_catch() "aarch64_pstate_za_shared" personality i32 0 {
; CHECK-LABEL: @multiple_catch(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @foo_shared()
; CHECK-NEXT:    to label [[RETURN:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr @overflow_error
; CHECK-NEXT:    catch ptr @runtime_error
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = tail call i32 @llvm.eh.typeid.for(ptr nonnull @overflow_error)
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i32 [[TMP2]], [[TMP3]]
; CHECK-NEXT:    br i1 [[MATCHES]], label [[CATCH1:%.*]], label [[CATCH_FALLTHROUGH:%.*]]
; CHECK:       catch1:
; CHECK-NEXT:    [[TMP4:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[LIVE1:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC2:%.*]] = trunc i64 [[LIVE1]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE3:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC2]], ptr [[TPIDR2_OBJ_LIVE3]], align 2
; CHECK-NEXT:    [[TPI_INT4:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT4]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @bar_shared()
; CHECK-NEXT:    to label [[RETURN_SINK_SPLIT:%.*]] unwind label [[LPAD3:%.*]]
; CHECK:       catch.fallthrough:
; CHECK-NEXT:    [[TMP5:%.*]] = tail call i32 @llvm.eh.typeid.for(ptr nonnull @runtime_error)
; CHECK-NEXT:    [[MATCHES1:%.*]] = icmp eq i32 [[TMP2]], [[TMP5]]
; CHECK-NEXT:    br i1 [[MATCHES1]], label [[CATCH2:%.*]], label [[EH_RESUME:%.*]]
; CHECK:       catch2:
; CHECK-NEXT:    [[TMP6:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[LIVE5:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC6:%.*]] = trunc i64 [[LIVE5]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE7:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC6]], ptr [[TPIDR2_OBJ_LIVE7]], align 2
; CHECK-NEXT:    [[TPI_INT8:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT8]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @fizz_shared()
; CHECK-NEXT:    to label [[RETURN_SINK_SPLIT]] unwind label [[LPAD2:%.*]]
; CHECK:       lpad2:
; CHECK-NEXT:    [[TMP7:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    cleanup
; CHECK-NEXT:    [[LIVE9:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC10:%.*]] = trunc i64 [[LIVE9]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE11:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC10]], ptr [[TPIDR2_OBJ_LIVE11]], align 2
; CHECK-NEXT:    [[TPI_INT12:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT12]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
; CHECK:       lpad3:
; CHECK-NEXT:    [[TMP8:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    cleanup
; CHECK-NEXT:    [[LIVE15:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC16:%.*]] = trunc i64 [[LIVE15]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE17:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC16]], ptr [[TPIDR2_OBJ_LIVE17]], align 2
; CHECK-NEXT:    [[TPI_INT18:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT18]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA13:%.*]] unwind label [[TERMINATE_LPAD]]
; CHECK:       return.sink.split:
; CHECK-NEXT:    [[RETVAL_PH:%.*]] = phi i32 [ 42, [[CATCH1]] ], [ 23, [[CATCH2]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[RETURN]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ 42, [[ENTRY:%.*]] ], [ [[RETVAL_PH]], [[RETURN_SINK_SPLIT]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    ret i32 [[RETVAL]]
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[EH_RESUME]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_RESUME]]
; CHECK:       check.za13:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR219:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP20:%.*]] = icmp eq i64 [[TPIDR219]], 0
; CHECK-NEXT:    br i1 [[CMP20]], label [[RESTORE_ZA14:%.*]], label [[EH_RESUME]]
; CHECK:       restore.za14:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_RESUME]]
; CHECK:       eh.resume:
; CHECK-NEXT:    [[LPAD_VAL13_MERGED:%.*]] = phi { ptr, i32 } [ [[TMP0]], [[CATCH_FALLTHROUGH]] ], [ [[TMP7]], [[CHECK_ZA]] ], [ [[TMP8]], [[CHECK_ZA13]] ], [ [[TMP7]], [[RESTORE_ZA]] ], [ [[TMP8]], [[RESTORE_ZA14]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    resume { ptr, i32 } [[LPAD_VAL13_MERGED]]
; CHECK:       terminate.lpad:
; CHECK-NEXT:    [[TMP9:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP10:%.*]] = extractvalue { ptr, i32 } [[TMP9]], 0
; CHECK-NEXT:    tail call void @__clang_call_terminate(ptr [[TMP10]])
; CHECK-NEXT:    unreachable
;
entry:
  invoke void @foo_shared()
  to label %return unwind label %lpad1

lpad1:
  %0 = landingpad { ptr, i32 }
  catch ptr @overflow_error
  catch ptr @runtime_error
  %1 = extractvalue { ptr, i32 } %0, 0
  %2 = extractvalue { ptr, i32 } %0, 1
  %3 = tail call i32 @llvm.eh.typeid.for(ptr nonnull @overflow_error)
  %matches = icmp eq i32 %2, %3
  br i1 %matches, label %catch1, label %catch.fallthrough

catch1:
  %4 = tail call ptr @__cxa_begin_catch(ptr %1)
  invoke void @bar_shared()
  to label %return.sink.split unwind label %lpad3

catch.fallthrough:
  %5 = tail call i32 @llvm.eh.typeid.for(ptr nonnull @runtime_error)
  %matches1 = icmp eq i32 %2, %5
  br i1 %matches1, label %catch2, label %eh.resume

catch2:
  %6 = tail call ptr @__cxa_begin_catch(ptr %1)
  invoke void @fizz_shared()
  to label %return.sink.split unwind label %lpad2

lpad2:
  %7 = landingpad { ptr, i32 }
  cleanup
  invoke void @__cxa_end_catch()
  to label %eh.resume unwind label %terminate.lpad

lpad3:
  %8 = landingpad { ptr, i32 }
  cleanup
  invoke void @__cxa_end_catch()
  to label %eh.resume unwind label %terminate.lpad

return.sink.split:
  %retval.ph = phi i32 [ 42, %catch1 ], [ 23, %catch2 ]
  tail call void @__cxa_end_catch()
  br label %return

return:
  %retval = phi i32 [ 42, %entry ], [ %retval.ph, %return.sink.split ]
  ret i32 %retval

eh.resume:
  %lpad.val13.merged = phi { ptr, i32 } [ %0, %catch.fallthrough ], [ %7, %lpad2 ], [ %8, %lpad3 ]
  resume { ptr, i32 } %lpad.val13.merged

terminate.lpad:
  %9 = landingpad { ptr, i32 }
  catch ptr null
  %10 = extractvalue { ptr, i32 } %9, 0
  tail call void @__clang_call_terminate(ptr %10)
  unreachable
}

;
; Try/Catch with throw in try block. Set up & restore lazy-save
;
; void try_throw() {
;   try {
;     throw 23;
;   } catch (...) {
;     foo();
;   }
;   bar();
;   return;
; }

define void @try_throw() "aarch64_pstate_za_shared" personality i32 1 {
; CHECK-LABEL: @try_throw(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[EXCEPTION:%.*]] = tail call ptr @__cxa_allocate_exception(i64 4)
; CHECK-NEXT:    store i32 23, ptr [[EXCEPTION]], align 4
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_throw(ptr nonnull [[EXCEPTION]], ptr nonnull @except, ptr null)
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[LPAD:%.*]]
; CHECK:       lpad:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[LIVE1:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC2:%.*]] = trunc i64 [[LIVE1]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE3:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC2]], ptr [[TPIDR2_OBJ_LIVE3]], align 2
; CHECK-NEXT:    [[TPI_INT4:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT4]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @foo_shared()
; CHECK-NEXT:    to label [[INVOKE_CONT:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       invoke.cont:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    tail call void @bar_shared()
; CHECK-NEXT:    ret void
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP3:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    cleanup
; CHECK-NEXT:    [[LIVE7:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC8:%.*]] = trunc i64 [[LIVE7]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE9:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC8]], ptr [[TPIDR2_OBJ_LIVE9]], align 2
; CHECK-NEXT:    [[TPI_INT10:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT10]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA5:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
; CHECK:       check.za5:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR211:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP12:%.*]] = icmp eq i64 [[TPIDR211]], 0
; CHECK-NEXT:    br i1 [[CMP12]], label [[RESTORE_ZA6:%.*]], label [[EH_RESUME:%.*]]
; CHECK:       restore.za6:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_RESUME]]
; CHECK:       eh.resume:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    resume { ptr, i32 } [[TMP3]]
; CHECK:       terminate.lpad:
; CHECK-NEXT:    [[TMP4:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { ptr, i32 } [[TMP4]], 0
; CHECK-NEXT:    tail call void @__clang_call_terminate(ptr [[TMP5]])
; CHECK-NEXT:    unreachable
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[UNREACHABLE:%.*]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[UNREACHABLE]]
; CHECK:       unreachable:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    unreachable
;
entry:
  %exception = tail call ptr @__cxa_allocate_exception(i64 4)
  store i32 23, ptr %exception
  invoke void @__cxa_throw(ptr nonnull %exception, ptr nonnull @except, ptr null)
  to label %unreachable unwind label %lpad

lpad:
  %0 = landingpad { ptr, i32 }
  catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  %2 = tail call ptr @__cxa_begin_catch(ptr %1)
  invoke void @foo_shared()
  to label %invoke.cont unwind label %lpad1

invoke.cont:
  tail call void @__cxa_end_catch()
  tail call void @bar_shared()
  ret void

lpad1:
  %3 = landingpad { ptr, i32 }
  cleanup
  invoke void @__cxa_end_catch()
  to label %eh.resume unwind label %terminate.lpad

eh.resume:
  resume { ptr, i32 } %3

terminate.lpad:
  %4 = landingpad { ptr, i32 }
  catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5)
  unreachable

unreachable:
  unreachable
}

;
; Try/Catch with throw in catch block. Set up & restore lazy-save
;
; void throw_except() {
;   try {
;     foo();
;   } catch (...) {
;     throw 23;
;   }
;   bar();
;   return;
; }

define void @catch_throw() "aarch64_pstate_za_shared" personality i32 0 {
; CHECK-LABEL: @catch_throw(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @foo_shared()
; CHECK-NEXT:    to label [[TRY_CONT:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[EXCEPTION:%.*]] = tail call ptr @__cxa_allocate_exception(i64 4)
; CHECK-NEXT:    store i32 23, ptr [[EXCEPTION]], align 4
; CHECK-NEXT:    [[LIVE1:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC2:%.*]] = trunc i64 [[LIVE1]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE3:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC2]], ptr [[TPIDR2_OBJ_LIVE3]], align 2
; CHECK-NEXT:    [[TPI_INT4:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT4]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_throw(ptr nonnull [[EXCEPTION]], ptr nonnull @except, ptr null)
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[LPAD2:%.*]]
; CHECK:       lpad2:
; CHECK-NEXT:    [[TMP3:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    cleanup
; CHECK-NEXT:    [[LIVE7:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC8:%.*]] = trunc i64 [[LIVE7]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE9:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC8]], ptr [[TPIDR2_OBJ_LIVE9]], align 2
; CHECK-NEXT:    [[TPI_INT10:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT10]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA5:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
; CHECK:       try.cont:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    tail call void @bar_shared()
; CHECK-NEXT:    ret void
; CHECK:       check.za5:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR211:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP12:%.*]] = icmp eq i64 [[TPIDR211]], 0
; CHECK-NEXT:    br i1 [[CMP12]], label [[RESTORE_ZA6:%.*]], label [[EH_RESUME:%.*]]
; CHECK:       restore.za6:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_RESUME]]
; CHECK:       eh.resume:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    resume { ptr, i32 } [[TMP3]]
; CHECK:       terminate.lpad:
; CHECK-NEXT:    [[TMP4:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { ptr, i32 } [[TMP4]], 0
; CHECK-NEXT:    tail call void @__clang_call_terminate(ptr [[TMP5]])
; CHECK-NEXT:    unreachable
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[UNREACHABLE:%.*]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[UNREACHABLE]]
; CHECK:       unreachable:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    unreachable
;
entry:
  invoke void @foo_shared()
  to label %try.cont unwind label %lpad1

lpad1:
  %0 = landingpad { ptr, i32 }
  catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  %2 = tail call ptr @__cxa_begin_catch(ptr %1)
  %exception = tail call ptr @__cxa_allocate_exception(i64 4)
  store i32 23, ptr %exception
  invoke void @__cxa_throw(ptr nonnull %exception, ptr nonnull @except, ptr null)
  to label %unreachable unwind label %lpad2

lpad2:
  %3 = landingpad { ptr, i32 }
  cleanup
  invoke void @__cxa_end_catch()
  to label %eh.resume unwind label %terminate.lpad

try.cont:
  tail call void @bar_shared()
  ret void

eh.resume:
  resume { ptr, i32 } %3

terminate.lpad:
  %4 = landingpad { ptr, i32 }
  catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5)
  unreachable

unreachable:
  unreachable
}

;
; Nested Try/Catch. Set up & restore lazy-save
;
; void nested() {
;   try {
;     foo();
;     try {
;       bar();
;     } catch (const std::runtime_error& e) {
;       fizz();
;     }
;   }
;   catch (...) {
;     buzz();
;   }
; }

define void @nested() "aarch64_pstate_za_shared" personality i32 0 {
; CHECK-LABEL: @nested(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @foo_shared()
; CHECK-NEXT:    to label [[INVOKE_CONT1:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       invoke.cont1:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    [[LIVE1:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC2:%.*]] = trunc i64 [[LIVE1]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE3:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC2]], ptr [[TPIDR2_OBJ_LIVE3]], align 2
; CHECK-NEXT:    [[TPI_INT4:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT4]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @bar_shared()
; CHECK-NEXT:    to label [[TRY_CONT14:%.*]] unwind label [[LPAD2:%.*]]
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    br label [[CATCH2:%.*]]
; CHECK:       lpad2:
; CHECK-NEXT:    [[TMP2:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr @runtime_error
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, i32 } [[TMP2]], 0
; CHECK-NEXT:    [[TMP4:%.*]] = extractvalue { ptr, i32 } [[TMP2]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = tail call i32 @llvm.eh.typeid.for(ptr nonnull @runtime_error)
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i32 [[TMP4]], [[TMP5]]
; CHECK-NEXT:    br i1 [[MATCHES]], label [[CATCH1:%.*]], label [[CATCH2]]
; CHECK:       catch1:
; CHECK-NEXT:    [[TMP6:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP3]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[LIVE5:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC6:%.*]] = trunc i64 [[LIVE5]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE7:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC6]], ptr [[TPIDR2_OBJ_LIVE7]], align 2
; CHECK-NEXT:    [[TPI_INT8:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT8]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @fizz_shared()
; CHECK-NEXT:    to label [[INVOKE_CONT2:%.*]] unwind label [[LPAD3:%.*]]
; CHECK:       invoke.cont2:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    [[LIVE9:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC10:%.*]] = trunc i64 [[LIVE9]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE11:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC10]], ptr [[TPIDR2_OBJ_LIVE11]], align 2
; CHECK-NEXT:    [[TPI_INT12:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT12]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[LPAD4:%.*]]
; CHECK:       lpad3:
; CHECK-NEXT:    [[TMP7:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[LIVE15:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC16:%.*]] = trunc i64 [[LIVE15]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE17:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC16]], ptr [[TPIDR2_OBJ_LIVE17]], align 2
; CHECK-NEXT:    [[TPI_INT18:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT18]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA13:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
; CHECK:       lpad4:
; CHECK-NEXT:    [[TMP8:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    br label [[EH_CLEANUP:%.*]]
; CHECK:       check.za13:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR219:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP20:%.*]] = icmp eq i64 [[TPIDR219]], 0
; CHECK-NEXT:    br i1 [[CMP20]], label [[RESTORE_ZA14:%.*]], label [[EH_CLEANUP]]
; CHECK:       restore.za14:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_CLEANUP]]
; CHECK:       eh.cleanup:
; CHECK-NEXT:    [[PN:%.*]] = phi { ptr, i32 } [ [[TMP8]], [[LPAD4]] ], [ [[TMP7]], [[CHECK_ZA13]] ], [ [[TMP7]], [[RESTORE_ZA14]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    [[EXN_SLOT_0:%.*]] = extractvalue { ptr, i32 } [[PN]], 0
; CHECK-NEXT:    br label [[CATCH2]]
; CHECK:       catch2:
; CHECK-NEXT:    [[EXN_SLOT_1:%.*]] = phi ptr [ [[EXN_SLOT_0]], [[EH_CLEANUP]] ], [ [[TMP3]], [[LPAD2]] ], [ [[TMP1]], [[LPAD1]] ]
; CHECK-NEXT:    [[TMP9:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[EXN_SLOT_1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[LIVE21:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC22:%.*]] = trunc i64 [[LIVE21]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE23:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC22]], ptr [[TPIDR2_OBJ_LIVE23]], align 2
; CHECK-NEXT:    [[TPI_INT24:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT24]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @buzz_shared()
; CHECK-NEXT:    to label [[INVOKE_CONT3:%.*]] unwind label [[LPAD5:%.*]]
; CHECK:       invoke.cont3:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[TRY_CONT14]]
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[TRY_CONT14]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[TRY_CONT14]]
; CHECK:       try.cont14:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    ret void
; CHECK:       lpad5:
; CHECK-NEXT:    [[TMP10:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    cleanup
; CHECK-NEXT:    [[LIVE27:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC28:%.*]] = trunc i64 [[LIVE27]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE29:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC28]], ptr [[TPIDR2_OBJ_LIVE29]], align 2
; CHECK-NEXT:    [[TPI_INT30:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT30]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA25:%.*]] unwind label [[TERMINATE_LPAD]]
; CHECK:       check.za25:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR231:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP32:%.*]] = icmp eq i64 [[TPIDR231]], 0
; CHECK-NEXT:    br i1 [[CMP32]], label [[RESTORE_ZA26:%.*]], label [[EH_RESUME:%.*]]
; CHECK:       restore.za26:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_RESUME]]
; CHECK:       eh.resume:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    resume { ptr, i32 } [[TMP10]]
; CHECK:       terminate.lpad:
; CHECK-NEXT:    [[TMP11:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP12:%.*]] = extractvalue { ptr, i32 } [[TMP11]], 0
; CHECK-NEXT:    tail call void @__clang_call_terminate(ptr [[TMP12]])
; CHECK-NEXT:    unreachable
;
entry:
  invoke void @foo_shared()
  to label %invoke.cont1 unwind label %lpad1

invoke.cont1:
  invoke void @bar_shared()
  to label %try.cont14 unwind label %lpad2

lpad1:
  %0 = landingpad { ptr, i32 }
  catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  br label %catch2

lpad2:
  %2 = landingpad { ptr, i32 }
  catch ptr @runtime_error
  catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  %4 = extractvalue { ptr, i32 } %2, 1
  %5 = tail call i32 @llvm.eh.typeid.for(ptr nonnull @runtime_error)
  %matches = icmp eq i32 %4, %5
  br i1 %matches, label %catch1, label %catch2

catch1:
  %6 = tail call ptr @__cxa_begin_catch(ptr %3)
  invoke void @fizz_shared()
  to label %invoke.cont2 unwind label %lpad3

invoke.cont2:
  invoke void @__cxa_end_catch()
  to label %try.cont14 unwind label %lpad4

lpad3:
  %7 = landingpad { ptr, i32 }
  catch ptr null
  invoke void @__cxa_end_catch()
  to label %eh.cleanup unwind label %terminate.lpad

lpad4:
  %8 = landingpad { ptr, i32 }
  catch ptr null
  br label %eh.cleanup

eh.cleanup:
  %pn = phi { ptr, i32 } [ %8, %lpad4 ], [ %7, %lpad3 ]
  %exn.slot.0 = extractvalue { ptr, i32 } %pn, 0
  br label %catch2

catch2:
  %exn.slot.1 = phi ptr [ %exn.slot.0, %eh.cleanup ], [ %3, %lpad2 ], [ %1, %lpad1 ]
  %9 = tail call ptr @__cxa_begin_catch(ptr %exn.slot.1)
  invoke void @buzz_shared()
  to label %invoke.cont3 unwind label %lpad5

invoke.cont3:
  tail call void @__cxa_end_catch()
  br label %try.cont14

try.cont14:
  ret void

lpad5:
  %10 = landingpad { ptr, i32 }
  cleanup
  invoke void @__cxa_end_catch()
  to label %eh.resume unwind label %terminate.lpad

eh.resume:
  resume { ptr, i32 } %10

terminate.lpad:
  %11 = landingpad { ptr, i32 }
  catch ptr null
  %12 = extractvalue { ptr, i32 } %11, 0
  tail call void @__clang_call_terminate(ptr %12)
  unreachable
}

; void try_condition(bool cond) {
;   try {
;     if (cond) {
;       throw 23;
;     }
;     bar();
;   }
;   catch (...) {
;     fizz();
;   }
; }

define void @conditional_throw(i1 %cond) "aarch64_pstate_za_shared" personality i32 0 {
; CHECK-LABEL: @conditional_throw(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    br i1 [[COND:%.*]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[EXCEPTION:%.*]] = tail call ptr @__cxa_allocate_exception(i64 4)
; CHECK-NEXT:    store i32 23, ptr [[EXCEPTION]], align 16
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_throw(ptr nonnull [[EXCEPTION]], ptr nonnull @except, ptr null)
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[LPAD:%.*]]
; CHECK:       lpad:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP1]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[LIVE1:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC2:%.*]] = trunc i64 [[LIVE1]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE3:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC2]], ptr [[TPIDR2_OBJ_LIVE3]], align 2
; CHECK-NEXT:    [[TPI_INT4:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT4]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @fizz_shared()
; CHECK-NEXT:    to label [[INVOKE_CONT2:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       invoke.cont2:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[TRY_CONT:%.*]]
; CHECK:       try.cont:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    ret void
; CHECK:       if.end:
; CHECK-NEXT:    [[LIVE5:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC6:%.*]] = trunc i64 [[LIVE5]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE7:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC6]], ptr [[TPIDR2_OBJ_LIVE7]], align 2
; CHECK-NEXT:    [[TPI_INT8:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT8]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @bar_shared()
; CHECK-NEXT:    to label [[TRY_CONT]] unwind label [[LPAD]]
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP3:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    cleanup
; CHECK-NEXT:    [[LIVE11:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC12:%.*]] = trunc i64 [[LIVE11]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE13:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC12]], ptr [[TPIDR2_OBJ_LIVE13]], align 2
; CHECK-NEXT:    [[TPI_INT14:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT14]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA9:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
; CHECK:       check.za9:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR215:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP16:%.*]] = icmp eq i64 [[TPIDR215]], 0
; CHECK-NEXT:    br i1 [[CMP16]], label [[RESTORE_ZA10:%.*]], label [[EH_RESUME:%.*]]
; CHECK:       restore.za10:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_RESUME]]
; CHECK:       eh.resume:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    resume { ptr, i32 } [[TMP3]]
; CHECK:       terminate.lpad:
; CHECK-NEXT:    [[TMP4:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP5:%.*]] = extractvalue { ptr, i32 } [[TMP4]], 0
; CHECK-NEXT:    tail call void @__clang_call_terminate(ptr [[TMP5]])
; CHECK-NEXT:    unreachable
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[UNREACHABLE:%.*]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[UNREACHABLE]]
; CHECK:       unreachable:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    unreachable
;
entry:
  br i1 %cond, label %if.then, label %if.end

if.then:
  %exception = tail call ptr @__cxa_allocate_exception(i64 4)
  store i32 23, ptr %exception, align 16
  invoke void @__cxa_throw(ptr nonnull %exception, ptr nonnull @except, ptr null)
  to label %unreachable unwind label %lpad

lpad:
  %0 = landingpad { ptr, i32 }
  catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  %2 = tail call ptr @__cxa_begin_catch(ptr %1)
  invoke void @fizz_shared()
  to label %invoke.cont2 unwind label %lpad1

invoke.cont2:
  tail call void @__cxa_end_catch()
  br label %try.cont

try.cont:
  ret void

if.end:
  invoke void @bar_shared()
  to label %try.cont unwind label %lpad

lpad1:
  %3 = landingpad { ptr, i32 }
  cleanup
  invoke void @__cxa_end_catch()
  to label %eh.resume unwind label %terminate.lpad

eh.resume:
  resume { ptr, i32 } %3

terminate.lpad:
  %4 = landingpad { ptr, i32 }
  catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  tail call void @__clang_call_terminate(ptr %5)
  unreachable

unreachable:
  unreachable
}

;
; int foo_throw(bool a) throw(const char *) {
;   if (a) {
;     bar();
;     return 42;
;   }
;   fizz();
;   return 23;
; }
;

define i32 @throw_in_signature(i1 %a) "aarch64_pstate_za_shared" personality i32 1 {
; CHECK-LABEL: @throw_in_signature(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    br i1 [[A:%.*]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @bar_shared()
; CHECK-NEXT:    to label [[RETURN:%.*]] unwind label [[LPAD:%.*]]
; CHECK:       lpad:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    filter [1 x ptr] [ptr @except]
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 1
; CHECK-NEXT:    [[EHSPEC_FAILS:%.*]] = icmp slt i32 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[EHSPEC_FAILS]], label [[EHSPEC_UNEXPECTED:%.*]], label [[EH_RESUME:%.*]]
; CHECK:       ehspec.unexpected:
; CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    tail call void @__cxa_call_unexpected(ptr [[TMP2]])
; CHECK-NEXT:    unreachable
; CHECK:       if.end:
; CHECK-NEXT:    [[LIVE1:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC2:%.*]] = trunc i64 [[LIVE1]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE3:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC2]], ptr [[TPIDR2_OBJ_LIVE3]], align 2
; CHECK-NEXT:    [[TPI_INT4:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT4]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @fizz_shared()
; CHECK-NEXT:    to label [[RETURN]] unwind label [[LPAD]]
; CHECK:       return:
; CHECK-NEXT:    [[RETVAL:%.*]] = phi i32 [ 42, [[IF_THEN]] ], [ 23, [[IF_END]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    ret i32 [[RETVAL]]
; CHECK:       eh.resume:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    resume { ptr, i32 } [[TMP0]]
;
entry:
  br i1 %a, label %if.then, label %if.end

if.then:
  invoke void @bar_shared()
  to label %return unwind label %lpad

lpad:
  %0 = landingpad { ptr, i32 }
  filter [1 x ptr] [ptr @except]
  %1 = extractvalue { ptr, i32 } %0, 1
  %ehspec.fails = icmp slt i32 %1, 0
  br i1 %ehspec.fails, label %ehspec.unexpected, label %eh.resume

ehspec.unexpected:
  %2 = extractvalue { ptr, i32 } %0, 0
  tail call void @__cxa_call_unexpected(ptr %2) #2
  unreachable

if.end:
  invoke void @fizz_shared()
  to label %return unwind label %lpad

return:
  %retval = phi i32 [ 42, %if.then ], [ 23, %if.end ]
  ret i32 %retval

eh.resume:
  resume { ptr, i32 } %0
}

;
; void try_func() try {
;   fizz();
; }
; catch (const std::runtime_error& e) {
;   buzz();
; }
;

define void @try_func() "aarch64_pstate_za_shared" personality i32 1 {
; CHECK-LABEL: @try_func(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ:%.*]] = alloca { ptr, i16, [6 x i8] }, align 8
; CHECK-NEXT:    [[N:%.*]] = call i64 @llvm.aarch64.sme.cntsb()
; CHECK-NEXT:    [[NN:%.*]] = mul i64 [[N]], [[N]]
; CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8, i64 [[NN]], align 16
; CHECK-NEXT:    [[TPIDR2_INVOKE_OBJ_BUFFER:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 0
; CHECK-NEXT:    store ptr [[BUFFER]], ptr [[TPIDR2_INVOKE_OBJ_BUFFER]], align 8
; CHECK-NEXT:    [[ZERO:%.*]] = alloca i48, i48 0, align 16
; CHECK-NEXT:    [[RESERVED:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 2
; CHECK-NEXT:    store ptr [[ZERO]], ptr [[RESERVED]], align 8
; CHECK-NEXT:    [[LIVE:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC:%.*]] = trunc i64 [[LIVE]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC]], ptr [[TPIDR2_OBJ_LIVE]], align 2
; CHECK-NEXT:    [[TPI_INT:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @fizz_shared()
; CHECK-NEXT:    to label [[TRY_CONT:%.*]] unwind label [[LPAD:%.*]]
; CHECK:       lpad:
; CHECK-NEXT:    [[TMP0:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr @runtime_error
; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = tail call i32 @llvm.eh.typeid.for(ptr nonnull @runtime_error)
; CHECK-NEXT:    [[MATCHES:%.*]] = icmp eq i32 [[TMP1]], [[TMP2]]
; CHECK-NEXT:    br i1 [[MATCHES]], label [[CATCH:%.*]], label [[EH_RESUME:%.*]]
; CHECK:       catch:
; CHECK-NEXT:    [[TMP3:%.*]] = extractvalue { ptr, i32 } [[TMP0]], 0
; CHECK-NEXT:    [[TMP4:%.*]] = tail call ptr @__cxa_begin_catch(ptr [[TMP3]])
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    [[LIVE1:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC2:%.*]] = trunc i64 [[LIVE1]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE3:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC2]], ptr [[TPIDR2_OBJ_LIVE3]], align 2
; CHECK-NEXT:    [[TPI_INT4:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT4]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    invoke void @buzz_shared()
; CHECK-NEXT:    to label [[INVOKE_CONT:%.*]] unwind label [[LPAD1:%.*]]
; CHECK:       invoke.cont:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    tail call void @__cxa_end_catch()
; CHECK-NEXT:    br label [[TRY_CONT]]
; CHECK:       try.cont:
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    ret void
; CHECK:       lpad1:
; CHECK-NEXT:    [[TMP5:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    cleanup
; CHECK-NEXT:    [[LIVE5:%.*]] = call i64 @llvm.aarch64.sme.get.live.za.slices()
; CHECK-NEXT:    [[LIVE_TRUNC6:%.*]] = trunc i64 [[LIVE5]] to i16
; CHECK-NEXT:    [[TPIDR2_OBJ_LIVE7:%.*]] = getelementptr { ptr, i16, [6 x i8] }, ptr [[TPIDR2_INVOKE_OBJ]], i64 0, i32 1
; CHECK-NEXT:    store i16 [[LIVE_TRUNC6]], ptr [[TPIDR2_OBJ_LIVE7]], align 2
; CHECK-NEXT:    [[TPI_INT8:%.*]] = ptrtoint ptr [[TPIDR2_INVOKE_OBJ]] to i64
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 [[TPI_INT8]])
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_save()
; CHECK-NEXT:    invoke void @__cxa_end_catch()
; CHECK-NEXT:    to label [[CHECK_ZA:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
; CHECK:       check.za:
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.enable()
; CHECK-NEXT:    [[TPIDR2:%.*]] = call i64 @llvm.aarch64.sme.get.tpidr2()
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TPIDR2]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[RESTORE_ZA:%.*]], label [[EH_RESUME]]
; CHECK:       restore.za:
; CHECK-NEXT:    call aarch64_sme_preservemost_from_x0 void @__arm_tpidr2_restore(ptr [[TPIDR2_INVOKE_OBJ]])
; CHECK-NEXT:    br label [[EH_RESUME]]
; CHECK:       eh.resume:
; CHECK-NEXT:    [[LPAD_VAL6_MERGED:%.*]] = phi { ptr, i32 } [ [[TMP0]], [[LPAD]] ], [ [[TMP5]], [[CHECK_ZA]] ], [ [[TMP5]], [[RESTORE_ZA]] ]
; CHECK-NEXT:    call void @llvm.aarch64.sme.set.tpidr2(i64 0)
; CHECK-NEXT:    call void @llvm.aarch64.sme.za.disable()
; CHECK-NEXT:    resume { ptr, i32 } [[LPAD_VAL6_MERGED]]
; CHECK:       terminate.lpad:
; CHECK-NEXT:    [[TMP6:%.*]] = landingpad { ptr, i32 }
; CHECK-NEXT:    catch ptr null
; CHECK-NEXT:    [[TMP7:%.*]] = extractvalue { ptr, i32 } [[TMP6]], 0
; CHECK-NEXT:    tail call void @__clang_call_terminate(ptr [[TMP7]])
; CHECK-NEXT:    unreachable
;
entry:
  invoke void @fizz_shared()
  to label %try.cont unwind label %lpad

lpad:
  %0 = landingpad { ptr, i32 }
  catch ptr @runtime_error
  %1 = extractvalue { ptr, i32 } %0, 1
  %2 = tail call i32 @llvm.eh.typeid.for(ptr nonnull @runtime_error)
  %matches = icmp eq i32 %1, %2
  br i1 %matches, label %catch, label %eh.resume

catch:
  %3 = extractvalue { ptr, i32 } %0, 0
  %4 = tail call ptr @__cxa_begin_catch(ptr %3) #4
  invoke void @buzz_shared()
  to label %invoke.cont unwind label %lpad1

invoke.cont:
  tail call void @__cxa_end_catch()
  br label %try.cont

try.cont:
  ret void

lpad1:
  %5 = landingpad { ptr, i32 }
  cleanup
  invoke void @__cxa_end_catch()
  to label %eh.resume unwind label %terminate.lpad

eh.resume:
  %lpad.val6.merged = phi { ptr, i32 } [ %0, %lpad ], [ %5, %lpad1 ]
  resume { ptr, i32 } %lpad.val6.merged

terminate.lpad:
  %6 = landingpad { ptr, i32 }
  catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  tail call void @__clang_call_terminate(ptr %7)
  unreachable
}

declare i32 @llvm.eh.typeid.for(ptr)
declare ptr @__cxa_begin_catch(ptr)
declare void @__cxa_end_catch()
declare ptr @__cxa_allocate_exception(i64)
declare void @__cxa_throw(ptr, ptr, ptr)
declare void @__cxa_call_unexpected(ptr) noreturn
declare void @__clang_call_terminate(ptr) noreturn

; CHECK: attributes #0 = { "aarch64_pstate_za_shared" "target-features"="+sme" }
; CHECK: attributes #1 = { "aarch64_pstate_za_new" "target-features"="+sme" }
; CHECK: attributes #2 = { "target-features"="+sme" }
; CHECK: attributes #3 = { "aarch64_expanded_pstate_za" "aarch64_pstate_sm_enabled" "aarch64_pstate_za_shared" "target-features"="+sme" }
; CHECK: attributes #4 = { "aarch64_expanded_pstate_za" "aarch64_pstate_sm_compatible" "aarch64_pstate_za_shared" "target-features"="+sme" }
; CHECK: attributes #5 = { "aarch64_expanded_pstate_za" "aarch64_pstate_za_shared" "target-features"="+sme" }
; CHECK: attributes #6 = { "aarch64_expanded_pstate_za" "aarch64_pstate_za_new" "target-features"="+sme" }
; CHECK: attributes #7 = { nounwind memory(none) "target-features"="+sme" }
; CHECK: attributes #8 = { noreturn "target-features"="+sme" }
; CHECK: attributes #9 = { nocallback nofree nosync nounwind willreturn memory(none) }
; CHECK: attributes #10 = { nocallback nofree nosync nounwind willreturn }
; CHECK: attributes #11 = { "aarch64_pstate_sm_compatible" "aarch64_pstate_za_shared" }
; CHECK: attributes #12 = { "aarch64_pstate_sm_compatible" "aarch64_pstate_za_preserved" }
; CHECK: attributes #13 = { "aarch64_pstate_za_preserved" }
