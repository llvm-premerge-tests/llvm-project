; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -verify-machineinstrs -mtriple=aarch64-none-linux-gnu -disable-post-ra < %s | FileCheck %s
; RUN: llc -verify-machineinstrs -mtriple=arm64-apple-ios -frame-pointer=all -disable-post-ra < %s | FileCheck %s --check-prefix=CHECK-MACHO
; This test aims to check basic correctness of frame layout &
; frame access code. There are 8 functions in this test file,
; each function implements one element in the cartesian product
; of:
; . a function having a VLA/noVLA
; . a function with dynamic stack realignment/no dynamic stack realignment.
; . a function needing a frame pionter/no frame pointer,
; since the presence/absence of these has influence on the frame
; layout and which pointer to use to access various part of the
; frame (bp,sp,fp).
;
; Furthermore: in every test function:
; . there is always one integer and 1 floating point argument to be able
;   to check those are accessed correctly.
; . there is always one local variable to check that is accessed
;   correctly
;
; The LLVM-IR below was produced by clang on the following C++ code:
;extern "C" int g();
;extern "C" int novla_nodynamicrealign_call(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10,
;                                             double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10)
;{
;  // use an argument passed on the stack.
;  volatile int l1;
;  return i10 + (int)d10 + l1 + g();
;}
;extern "C" int novla_nodynamicrealign_nocall(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10,
;                                             double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10)
;{
;  // use an argument passed on the stack.
;  volatile int l1;
;  return i10 + (int)d10 + l1;
;}
;extern "C" int novla_dynamicrealign_call(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10,
;                                         double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10)
;{
;  // use an argument passed on the stack.
;  alignas(128) volatile int l1;
;  return i10 + (int)d10 + l1 + g();
;}
;extern "C" int novla_dynamicrealign_nocall(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10,
;                                           double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10)
;{
;  // use an argument passed on the stack.
;  alignas(128) volatile int l1;
;  return i10 + (int)d10 + l1;
;}
;
;extern "C" int vla_nodynamicrealign_call(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10,
;                                         double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10)
;{
;  // use an argument passed on the stack.
;  volatile int l1;
;  volatile int vla[i1];
;  return i10 + (int)d10 + l1 + g() + vla[0];
;}
;extern "C" int vla_nodynamicrealign_nocall(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10,
;                                           double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10)
;{
;  // use an argument passed on the stack.
;  volatile int l1;
;  volatile int vla[i1];
;  return i10 + (int)d10 + l1 + vla[0];
;}
;extern "C" int vla_dynamicrealign_call(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10,
;                                       double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10)
;{
;  // use an argument passed on the stack.
;  alignas(128) volatile int l1;
;  volatile int vla[i1];
;  return i10 + (int)d10 + l1 + g() + vla[0];
;}
;extern "C" int vla_dynamicrealign_nocall(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8, int i9, int i10,
;                                         double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10)
;{
;  // use an argument passed on the stack.
;  alignas(128) volatile int l1;
;  volatile int vla[i1];
;  return i10 + (int)d10 + l1 + vla[0];
;}
define i32 @novla_nodynamicrealign_call(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #0 {
;
; CHECK-LABEL: novla_nodynamicrealign_call:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    stp x30, x19, [sp, #16] // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    .cfi_offset w19, -8
; CHECK-NEXT:    .cfi_offset w30, -16
; CHECK-NEXT:    ldr d0, [sp, #56]
; CHECK-NEXT:    fcvtzs w8, d0
; CHECK-NEXT:    ldr w9, [sp, #40]
; CHECK-NEXT:    ldr w10, [sp, #12]
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    orr w19, w8, w10
; CHECK-NEXT:    bl g
; CHECK-NEXT:    add w0, w19, w0
; CHECK-NEXT:    ldp x30, x19, [sp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    add sp, sp, #32
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: novla_nodynamicrealign_call:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    sub sp, sp, #48
; CHECK-MACHO-NEXT:    stp x20, x19, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #32] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #32
; CHECK-MACHO-NEXT:    .cfi_def_cfa w29, 16
; CHECK-MACHO-NEXT:    .cfi_offset w30, -8
; CHECK-MACHO-NEXT:    .cfi_offset w29, -16
; CHECK-MACHO-NEXT:    .cfi_offset w19, -24
; CHECK-MACHO-NEXT:    .cfi_offset w20, -32
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    fcvtzs w8, d0
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldr w10, [sp, #12]
; CHECK-MACHO-NEXT:    add w8, w8, w9
; CHECK-MACHO-NEXT:    orr w19, w8, w10
; CHECK-MACHO-NEXT:    bl _g
; CHECK-MACHO-NEXT:    add w0, w19, w0
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #32] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x20, x19, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    add sp, sp, #48
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 4
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 4
  %add1 = or i32 %add, %l1.0.l1.0.
  %call = tail call i32 @g()
  %add2 = add nsw i32 %add1, %call
  ret i32 %add2
}
;   Check that used callee-saved registers are saved
;   Check correctness of cfi pseudo-instructions
;   Check correct access to arguments passed on the stack, through stack pointer
;   Check correct access to local variable on the stack, through stack pointer
;   Check epilogue:
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check correctness of cfi pseudo-instructions
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct access to local variable on the stack, through stack pointer
;   Check epilogue:
declare i32 @g() #0
; Function Attrs: nounwind
define i32 @novla_nodynamicrealign_nocall(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #1 {
;
; CHECK-LABEL: novla_nodynamicrealign_nocall:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #16
; CHECK-NEXT:    ldr d0, [sp, #40]
; CHECK-NEXT:    fcvtzs w8, d0
; CHECK-NEXT:    ldr w9, [sp, #24]
; CHECK-NEXT:    ldr w10, [sp, #12]
; CHECK-NEXT:    add w9, w9, w10
; CHECK-NEXT:    add w0, w8, w9
; CHECK-NEXT:    add sp, sp, #16
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: novla_nodynamicrealign_nocall:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    sub sp, sp, #32
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #16
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    fcvtzs w8, d0
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldur w10, [x29, #-4]
; CHECK-MACHO-NEXT:    add w9, w9, w10
; CHECK-MACHO-NEXT:    add w0, w8, w9
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    add sp, sp, #32
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 4
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 4
  %add1 = add nsw i32 %add, %l1.0.l1.0.
  ret i32 %add1
}
;   Check that space is reserved for one local variable on the stack.
;   Check correct access to arguments passed on the stack, through stack pointer
;   Check correct access to local variable on the stack, through stack pointer
;   Check epilogue:
define i32 @novla_dynamicrealign_call(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #0 {
;
; CHECK-LABEL: novla_dynamicrealign_call:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-32]! // 16-byte Folded Spill
; CHECK-NEXT:    str x19, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    sub x9, sp, #96
; CHECK-NEXT:    and sp, x9, #0xffffffffffffff80
; CHECK-NEXT:    .cfi_def_cfa w29, 32
; CHECK-NEXT:    .cfi_offset w19, -16
; CHECK-NEXT:    .cfi_offset w30, -24
; CHECK-NEXT:    .cfi_offset w29, -32
; CHECK-NEXT:    ldr d0, [x29, #56]
; CHECK-NEXT:    fcvtzs w8, d0
; CHECK-NEXT:    ldr w9, [x29, #40]
; CHECK-NEXT:    ldr w10, [sp]
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    orr w19, w8, w10
; CHECK-NEXT:    bl g
; CHECK-NEXT:    add w0, w19, w0
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldr x19, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    ldp x29, x30, [sp], #32 // 16-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: novla_dynamicrealign_call:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #16
; CHECK-MACHO-NEXT:    sub x9, sp, #96
; CHECK-MACHO-NEXT:    and sp, x9, #0xffffffffffffff80
; CHECK-MACHO-NEXT:    .cfi_def_cfa w29, 16
; CHECK-MACHO-NEXT:    .cfi_offset w30, -8
; CHECK-MACHO-NEXT:    .cfi_offset w29, -16
; CHECK-MACHO-NEXT:    .cfi_offset w19, -24
; CHECK-MACHO-NEXT:    .cfi_offset w20, -32
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    fcvtzs w8, d0
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldr w10, [sp]
; CHECK-MACHO-NEXT:    add w8, w8, w9
; CHECK-MACHO-NEXT:    orr w19, w8, w10
; CHECK-MACHO-NEXT:    bl _g
; CHECK-MACHO-NEXT:    add w0, w19, w0
; CHECK-MACHO-NEXT:    sub sp, x29, #16
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 128
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 128
  %add1 = or i32 %add, %l1.0.l1.0.
  %call = tail call i32 @g()
  %add2 = add nsw i32 %add1, %call
  ret i32 %add2
}
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check the dynamic realignment of the stack pointer to a 128-byte boundary
;   Check correctness of cfi pseudo-instructions
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct access to local variable on the stack, through re-aligned stack pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check the dynamic realignment of the stack pointer to a 128-byte boundary
;   Check correctness of cfi pseudo-instructions
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct access to local variable on the stack, through re-aligned stack pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
; Function Attrs: nounwind
define i32 @novla_dynamicrealign_nocall(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #1 {
;
; CHECK-LABEL: novla_dynamicrealign_nocall:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    sub x9, sp, #112
; CHECK-NEXT:    and sp, x9, #0xffffffffffffff80
; CHECK-NEXT:    ldr d0, [x29, #40]
; CHECK-NEXT:    fcvtzs w8, d0
; CHECK-NEXT:    ldr w9, [x29, #24]
; CHECK-NEXT:    ldr w10, [sp]
; CHECK-NEXT:    add w9, w9, w10
; CHECK-NEXT:    add w0, w8, w9
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: novla_dynamicrealign_nocall:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #-16]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    mov x29, sp
; CHECK-MACHO-NEXT:    sub x9, sp, #112
; CHECK-MACHO-NEXT:    and sp, x9, #0xffffffffffffff80
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    fcvtzs w8, d0
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldr w10, [sp]
; CHECK-MACHO-NEXT:    add w9, w9, w10
; CHECK-MACHO-NEXT:    add w0, w8, w9
; CHECK-MACHO-NEXT:    mov sp, x29
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp], #16 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 128
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 128
  %add1 = add nsw i32 %add, %l1.0.l1.0.
  ret i32 %add1
}
;   Check that the frame pointer is created:
;   Check the dynamic realignment of the stack pointer to a 128-byte boundary
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct access to local variable on the stack, through re-aligned stack pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
define i32 @vla_nodynamicrealign_call(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #0 {
;
; CHECK-LABEL: vla_nodynamicrealign_call:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-32]! // 16-byte Folded Spill
; CHECK-NEXT:    stp x20, x19, [sp, #16] // 16-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    sub sp, sp, #16
; CHECK-NEXT:    .cfi_def_cfa w29, 32
; CHECK-NEXT:    .cfi_offset w19, -8
; CHECK-NEXT:    .cfi_offset w20, -16
; CHECK-NEXT:    .cfi_offset w30, -24
; CHECK-NEXT:    .cfi_offset w29, -32
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-NEXT:    ldr w9, [x29, #40]
; CHECK-NEXT:    ldr d0, [x29, #56]
; CHECK-NEXT:    add x8, x8, #15
; CHECK-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-NEXT:    mov x10, sp
; CHECK-NEXT:    sub x19, x10, x8
; CHECK-NEXT:    mov sp, x19
; CHECK-NEXT:    fcvtzs w8, d0
; CHECK-NEXT:    ldur w10, [x29, #-4]
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    orr w20, w8, w10
; CHECK-NEXT:    bl g
; CHECK-NEXT:    ldr w8, [x19]
; CHECK-NEXT:    add w8, w0, w8
; CHECK-NEXT:    add w0, w20, w8
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldp x20, x19, [sp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    ldp x29, x30, [sp], #32 // 16-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: vla_nodynamicrealign_call:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #16
; CHECK-MACHO-NEXT:    sub sp, sp, #16
; CHECK-MACHO-NEXT:    .cfi_def_cfa w29, 16
; CHECK-MACHO-NEXT:    .cfi_offset w30, -8
; CHECK-MACHO-NEXT:    .cfi_offset w29, -16
; CHECK-MACHO-NEXT:    .cfi_offset w19, -24
; CHECK-MACHO-NEXT:    .cfi_offset w20, -32
; CHECK-MACHO-NEXT:    ; kill: def $w0 killed $w0 def $x0
; CHECK-MACHO-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    add x8, x8, #15
; CHECK-MACHO-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-MACHO-NEXT:    mov x10, sp
; CHECK-MACHO-NEXT:    sub x19, x10, x8
; CHECK-MACHO-NEXT:    mov sp, x19
; CHECK-MACHO-NEXT:    fcvtzs w8, d0
; CHECK-MACHO-NEXT:    ldur w10, [x29, #-20]
; CHECK-MACHO-NEXT:    add w8, w8, w9
; CHECK-MACHO-NEXT:    orr w20, w8, w10
; CHECK-MACHO-NEXT:    bl _g
; CHECK-MACHO-NEXT:    ldr w8, [x19]
; CHECK-MACHO-NEXT:    add w8, w0, w8
; CHECK-MACHO-NEXT:    add w0, w20, w8
; CHECK-MACHO-NEXT:    sub sp, x29, #16
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 4
  %0 = zext i32 %i1 to i64
  %vla = alloca i32, i64 %0, align 4
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 4
  %add1 = or i32 %add, %l1.0.l1.0.
  %call = tail call i32 @g()
  %add2 = add nsw i32 %add1, %call
  %1 = load volatile i32, ptr %vla, align 4, !tbaa !1
  %add3 = add nsw i32 %add2, %1
  ret i32 %add3
}
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check that space is reserved on the stack for the local variable,
;   rounded up to a multiple of 16 to keep the stack pointer 16-byte aligned.
;   Check correctness of cfi pseudo-instructions
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct reservation of 16-byte aligned VLA (size in w0) on stack
;   Check correct access to local variable, through frame pointer
;   Check correct accessing of the VLA variable through the base pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
; Function Attrs: nounwind
define i32 @vla_nodynamicrealign_nocall(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #1 {
;
; CHECK-LABEL: vla_nodynamicrealign_nocall:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    sub sp, sp, #16
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-NEXT:    ldr w9, [x29, #24]
; CHECK-NEXT:    ldr d0, [x29, #40]
; CHECK-NEXT:    add x8, x8, #15
; CHECK-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-NEXT:    mov x10, sp
; CHECK-NEXT:    sub x8, x10, x8
; CHECK-NEXT:    mov sp, x8
; CHECK-NEXT:    fcvtzs w10, d0
; CHECK-NEXT:    ldur w11, [x29, #-4]
; CHECK-NEXT:    add w9, w9, w11
; CHECK-NEXT:    ldr w8, [x8]
; CHECK-NEXT:    add w9, w10, w9
; CHECK-NEXT:    add w0, w9, w8
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: vla_nodynamicrealign_nocall:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #-16]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    mov x29, sp
; CHECK-MACHO-NEXT:    sub sp, sp, #16
; CHECK-MACHO-NEXT:    ; kill: def $w0 killed $w0 def $x0
; CHECK-MACHO-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    add x8, x8, #15
; CHECK-MACHO-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-MACHO-NEXT:    mov x10, sp
; CHECK-MACHO-NEXT:    sub x8, x10, x8
; CHECK-MACHO-NEXT:    mov sp, x8
; CHECK-MACHO-NEXT:    fcvtzs w10, d0
; CHECK-MACHO-NEXT:    ldur w11, [x29, #-4]
; CHECK-MACHO-NEXT:    add w9, w9, w11
; CHECK-MACHO-NEXT:    ldr w8, [x8]
; CHECK-MACHO-NEXT:    add w9, w10, w9
; CHECK-MACHO-NEXT:    add w0, w9, w8
; CHECK-MACHO-NEXT:    mov sp, x29
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp], #16 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 4
  %0 = zext i32 %i1 to i64
  %vla = alloca i32, i64 %0, align 4
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 4
  %add1 = add nsw i32 %add, %l1.0.l1.0.
  %1 = load volatile i32, ptr %vla, align 4, !tbaa !1
  %add2 = add nsw i32 %add1, %1
  ret i32 %add2
}
;   Check that the frame pointer is created:
;   Check that space is reserved on the stack for the local variable,
;   rounded up to a multiple of 16 to keep the stack pointer 16-byte aligned.
;   Check correctness of cfi pseudo-instructions
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct reservation of 16-byte aligned VLA (size in w0) on stack
;   Check correct access to local variable, through frame pointer
;   Check correct accessing of the VLA variable through the base pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
define i32 @vla_dynamicrealign_call(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #0 {
;
; CHECK-LABEL: vla_dynamicrealign_call:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-48]! // 16-byte Folded Spill
; CHECK-NEXT:    str x21, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    stp x20, x19, [sp, #32] // 16-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    sub x9, sp, #80
; CHECK-NEXT:    and sp, x9, #0xffffffffffffff80
; CHECK-NEXT:    mov x19, sp
; CHECK-NEXT:    .cfi_def_cfa w29, 48
; CHECK-NEXT:    .cfi_offset w19, -8
; CHECK-NEXT:    .cfi_offset w20, -16
; CHECK-NEXT:    .cfi_offset w21, -32
; CHECK-NEXT:    .cfi_offset w30, -40
; CHECK-NEXT:    .cfi_offset w29, -48
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-NEXT:    ldr w9, [x29, #56]
; CHECK-NEXT:    ldr d0, [x29, #72]
; CHECK-NEXT:    add x8, x8, #15
; CHECK-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-NEXT:    mov x10, sp
; CHECK-NEXT:    sub x20, x10, x8
; CHECK-NEXT:    mov sp, x20
; CHECK-NEXT:    fcvtzs w8, d0
; CHECK-NEXT:    ldr w10, [x19]
; CHECK-NEXT:    add w8, w8, w9
; CHECK-NEXT:    orr w21, w8, w10
; CHECK-NEXT:    bl g
; CHECK-NEXT:    ldr w8, [x20]
; CHECK-NEXT:    add w8, w0, w8
; CHECK-NEXT:    add w0, w21, w8
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldp x20, x19, [sp, #32] // 16-byte Folded Reload
; CHECK-NEXT:    ldr x21, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    ldp x29, x30, [sp], #48 // 16-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: vla_dynamicrealign_call:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    stp x22, x21, [sp, #-48]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x20, x19, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #32] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #32
; CHECK-MACHO-NEXT:    sub x9, sp, #80
; CHECK-MACHO-NEXT:    and sp, x9, #0xffffffffffffff80
; CHECK-MACHO-NEXT:    mov x19, sp
; CHECK-MACHO-NEXT:    .cfi_def_cfa w29, 16
; CHECK-MACHO-NEXT:    .cfi_offset w30, -8
; CHECK-MACHO-NEXT:    .cfi_offset w29, -16
; CHECK-MACHO-NEXT:    .cfi_offset w19, -24
; CHECK-MACHO-NEXT:    .cfi_offset w20, -32
; CHECK-MACHO-NEXT:    .cfi_offset w21, -40
; CHECK-MACHO-NEXT:    .cfi_offset w22, -48
; CHECK-MACHO-NEXT:    ; kill: def $w0 killed $w0 def $x0
; CHECK-MACHO-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    add x8, x8, #15
; CHECK-MACHO-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-MACHO-NEXT:    mov x10, sp
; CHECK-MACHO-NEXT:    sub x20, x10, x8
; CHECK-MACHO-NEXT:    mov sp, x20
; CHECK-MACHO-NEXT:    fcvtzs w8, d0
; CHECK-MACHO-NEXT:    ldr w10, [x19]
; CHECK-MACHO-NEXT:    add w8, w8, w9
; CHECK-MACHO-NEXT:    orr w21, w8, w10
; CHECK-MACHO-NEXT:    bl _g
; CHECK-MACHO-NEXT:    ldr w8, [x20]
; CHECK-MACHO-NEXT:    add w8, w0, w8
; CHECK-MACHO-NEXT:    add w0, w21, w8
; CHECK-MACHO-NEXT:    sub sp, x29, #32
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #32] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x20, x19, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x22, x21, [sp], #48 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 128
  %0 = zext i32 %i1 to i64
  %vla = alloca i32, i64 %0, align 4
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 128
  %add1 = or i32 %add, %l1.0.l1.0.
  %call = tail call i32 @g()
  %add2 = add nsw i32 %add1, %call
  %1 = load volatile i32, ptr %vla, align 4, !tbaa !1
  %add3 = add nsw i32 %add2, %1
  ret i32 %add3
}
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check that the stack pointer gets re-aligned to 128
;   bytes & the base pointer (x19) gets initialized to
;   this 128-byte aligned area for local variables &
;   spill slots
;   Check correctness of cfi pseudo-instructions
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct reservation of 16-byte aligned VLA (size in w0) on stack
;   and set-up of base pointer (x19).
;   Check correct access to local variable, through base pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check that the stack pointer gets re-aligned to 128
;   bytes & the base pointer (x19) gets initialized to
;   this 128-byte aligned area for local variables &
;   spill slots
;   Check correctness of cfi pseudo-instructions
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct reservation of 16-byte aligned VLA (size in w0) on stack
;   and set-up of base pointer (x19).
;   Check correct access to local variable, through base pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
; Function Attrs: nounwind
define i32 @vla_dynamicrealign_nocall(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #1 {
;
; CHECK-LABEL: vla_dynamicrealign_nocall:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-32]! // 16-byte Folded Spill
; CHECK-NEXT:    str x19, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    sub x9, sp, #96
; CHECK-NEXT:    and sp, x9, #0xffffffffffffff80
; CHECK-NEXT:    mov x19, sp
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-NEXT:    ldr w9, [x29, #40]
; CHECK-NEXT:    ldr d0, [x29, #56]
; CHECK-NEXT:    add x8, x8, #15
; CHECK-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-NEXT:    mov x10, sp
; CHECK-NEXT:    sub x8, x10, x8
; CHECK-NEXT:    mov sp, x8
; CHECK-NEXT:    fcvtzs w10, d0
; CHECK-NEXT:    ldr w11, [x19]
; CHECK-NEXT:    add w9, w9, w11
; CHECK-NEXT:    ldr w8, [x8]
; CHECK-NEXT:    add w9, w10, w9
; CHECK-NEXT:    add w0, w9, w8
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldr x19, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    ldp x29, x30, [sp], #32 // 16-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: vla_dynamicrealign_nocall:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #16
; CHECK-MACHO-NEXT:    sub x9, sp, #96
; CHECK-MACHO-NEXT:    and sp, x9, #0xffffffffffffff80
; CHECK-MACHO-NEXT:    mov x19, sp
; CHECK-MACHO-NEXT:    ; kill: def $w0 killed $w0 def $x0
; CHECK-MACHO-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    add x8, x8, #15
; CHECK-MACHO-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-MACHO-NEXT:    mov x10, sp
; CHECK-MACHO-NEXT:    sub x8, x10, x8
; CHECK-MACHO-NEXT:    mov sp, x8
; CHECK-MACHO-NEXT:    fcvtzs w10, d0
; CHECK-MACHO-NEXT:    ldr w11, [x19]
; CHECK-MACHO-NEXT:    add w9, w9, w11
; CHECK-MACHO-NEXT:    ldr w8, [x8]
; CHECK-MACHO-NEXT:    add w9, w10, w9
; CHECK-MACHO-NEXT:    add w0, w9, w8
; CHECK-MACHO-NEXT:    sub sp, x29, #16
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 128
  %0 = zext i32 %i1 to i64
  %vla = alloca i32, i64 %0, align 4
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 128
  %add1 = add nsw i32 %add, %l1.0.l1.0.
  %1 = load volatile i32, ptr %vla, align 4, !tbaa !1
  %add2 = add nsw i32 %add1, %1
  ret i32 %add2
}
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check that the stack pointer gets re-aligned to 128
;   bytes & the base pointer (x19) gets initialized to
;   this 128-byte aligned area for local variables &
;   spill slots
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct reservation of 16-byte aligned VLA (size in w0) on stack
;   and set-up of base pointer (x19).
;   Check correct access to local variable, through base pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check that the stack pointer gets re-aligned to 128
;   bytes & the base pointer (x19) gets initialized to
;   this 128-byte aligned area for local variables &
;   spill slots
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct reservation of 16-byte aligned VLA (size in w0) on stack
;   and set-up of base pointer (x19).
;   Check correct access to local variable, through base pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
; Function Attrs: nounwind
define i32 @vla_dynamicrealign_nocall_large_align(i32 %i1, i32 %i2, i32 %i3, i32 %i4, i32 %i5, i32 %i6, i32 %i7, i32 %i8, i32 %i9, i32 %i10, double %d1, double %d2, double %d3, double %d4, double %d5, double %d6, double %d7, double %d8, double %d9, double %d10) #1 {
;
; CHECK-LABEL: vla_dynamicrealign_nocall_large_align:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-32]! // 16-byte Folded Spill
; CHECK-NEXT:    str x19, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    sub x9, sp, #7, lsl #12 // =28672
; CHECK-NEXT:    sub x9, x9, #4064
; CHECK-NEXT:    and sp, x9, #0xffffffffffff8000
; CHECK-NEXT:    mov x19, sp
; CHECK-NEXT:    // kill: def $w0 killed $w0 def $x0
; CHECK-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-NEXT:    ldr w9, [x29, #40]
; CHECK-NEXT:    ldr d0, [x29, #56]
; CHECK-NEXT:    add x8, x8, #15
; CHECK-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-NEXT:    mov x10, sp
; CHECK-NEXT:    sub x8, x10, x8
; CHECK-NEXT:    mov sp, x8
; CHECK-NEXT:    fcvtzs w10, d0
; CHECK-NEXT:    ldr w11, [x19]
; CHECK-NEXT:    add w9, w9, w11
; CHECK-NEXT:    ldr w8, [x8]
; CHECK-NEXT:    add w9, w10, w9
; CHECK-NEXT:    add w0, w9, w8
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldr x19, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    ldp x29, x30, [sp], #32 // 16-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: vla_dynamicrealign_nocall_large_align:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #16
; CHECK-MACHO-NEXT:    sub x9, sp, #7, lsl #12 ; =28672
; CHECK-MACHO-NEXT:    sub x9, x9, #4064
; CHECK-MACHO-NEXT:    and sp, x9, #0xffffffffffff8000
; CHECK-MACHO-NEXT:    mov x19, sp
; CHECK-MACHO-NEXT:    ; kill: def $w0 killed $w0 def $x0
; CHECK-MACHO-NEXT:    ubfiz x8, x0, #2, #32
; CHECK-MACHO-NEXT:    ldr w9, [x29, #20]
; CHECK-MACHO-NEXT:    ldr d0, [x29, #32]
; CHECK-MACHO-NEXT:    add x8, x8, #15
; CHECK-MACHO-NEXT:    and x8, x8, #0x7fffffff0
; CHECK-MACHO-NEXT:    mov x10, sp
; CHECK-MACHO-NEXT:    sub x8, x10, x8
; CHECK-MACHO-NEXT:    mov sp, x8
; CHECK-MACHO-NEXT:    fcvtzs w10, d0
; CHECK-MACHO-NEXT:    ldr w11, [x19]
; CHECK-MACHO-NEXT:    add w9, w9, w11
; CHECK-MACHO-NEXT:    ldr w8, [x8]
; CHECK-MACHO-NEXT:    add w9, w10, w9
; CHECK-MACHO-NEXT:    add w0, w9, w8
; CHECK-MACHO-NEXT:    sub sp, x29, #16
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ret
entry:
  %l1 = alloca i32, align 32768
  %0 = zext i32 %i1 to i64
  %vla = alloca i32, i64 %0, align 4
  %conv = fptosi double %d10 to i32
  %add = add nsw i32 %conv, %i10
  %l1.0.l1.0. = load volatile i32, ptr %l1, align 32768
  %add1 = add nsw i32 %add, %l1.0.l1.0.
  %1 = load volatile i32, ptr %vla, align 4, !tbaa !1
  %add2 = add nsw i32 %add1, %1
  ret i32 %add2
}
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check that the stack pointer gets re-aligned to 128
;   bytes & the base pointer (x19) gets initialized to
;   this 128-byte aligned area for local variables &
;   spill slots
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct reservation of 16-byte aligned VLA (size in w0) on stack
;   and set-up of base pointer (x19).
;   Check correct access to local variable, through base pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
;   Check that used callee-saved registers are saved
;   Check that the frame pointer is created:
;   Check that the stack pointer gets re-aligned to 128
;   bytes & the base pointer (x19) gets initialized to
;   this 128-byte aligned area for local variables &
;   spill slots
;   Check correct access to arguments passed on the stack, through frame pointer
;   Check correct reservation of 16-byte aligned VLA (size in w0) on stack
;   and set-up of base pointer (x19).
;   Check correct access to local variable, through base pointer
;   Check epilogue:
;     Check that stack pointer get restored from frame pointer.
declare void @use(ptr)
define void @realign_conditional(i1 %b, ptr %p) {
;
; CHECK-LABEL: realign_conditional:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    tbz w0, #0, .LBB9_2
; CHECK-NEXT:  // %bb.1: // %bb0
; CHECK-NEXT:    stp x29, x30, [sp, #-32]! // 16-byte Folded Spill
; CHECK-NEXT:    str x19, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    mov x19, sp
; CHECK-NEXT:    .cfi_def_cfa w29, 32
; CHECK-NEXT:    .cfi_offset w19, -16
; CHECK-NEXT:    .cfi_offset w30, -24
; CHECK-NEXT:    .cfi_offset w29, -32
; CHECK-NEXT:    sub x8, sp, #64
; CHECK-NEXT:    and x8, x8, #0xffffffffffffffe0
; CHECK-NEXT:    mov sp, x8
; CHECK-NEXT:    str x8, [x1]
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldr x19, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    ldp x29, x30, [sp], #32 // 16-byte Folded Reload
; CHECK-NEXT:  .LBB9_2: // %bb1
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: realign_conditional:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    tbz w0, #0, LBB9_2
; CHECK-MACHO-NEXT:  ; %bb.1: ; %bb0
; CHECK-MACHO-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #16
; CHECK-MACHO-NEXT:    mov x19, sp
; CHECK-MACHO-NEXT:    .cfi_def_cfa w29, 16
; CHECK-MACHO-NEXT:    .cfi_offset w30, -8
; CHECK-MACHO-NEXT:    .cfi_offset w29, -16
; CHECK-MACHO-NEXT:    .cfi_offset w19, -24
; CHECK-MACHO-NEXT:    .cfi_offset w20, -32
; CHECK-MACHO-NEXT:    sub x8, sp, #64
; CHECK-MACHO-NEXT:    and x8, x8, #0xffffffffffffffe0
; CHECK-MACHO-NEXT:    mov sp, x8
; CHECK-MACHO-NEXT:    str x8, [x1]
; CHECK-MACHO-NEXT:    sub sp, x29, #16
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:  LBB9_2: ; %bb1
; CHECK-MACHO-NEXT:    ret
entry:
  br i1 %b, label %bb0, label %bb1
bb0:
  %MyAlloca = alloca i8, i64 64, align 32
  store ptr %MyAlloca, ptr %p
  br label %bb1
bb1:
  ret void
}
; No realignment in the prologue.
; Stack is realigned in a non-entry BB.
define void @realign_conditional2(i1 %b, ptr %p) {
;
; CHECK-LABEL: realign_conditional2:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    tbz w0, #0, .LBB10_2
; CHECK-NEXT:  // %bb.1: // %bb0
; CHECK-NEXT:    stp x29, x30, [sp, #-32]! // 16-byte Folded Spill
; CHECK-NEXT:    str x19, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    sub x9, sp, #32
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-NEXT:    mov x19, sp
; CHECK-NEXT:    .cfi_def_cfa w29, 32
; CHECK-NEXT:    .cfi_offset w19, -16
; CHECK-NEXT:    .cfi_offset w30, -24
; CHECK-NEXT:    .cfi_offset w29, -32
; CHECK-NEXT:    sub x8, sp, #64
; CHECK-NEXT:    and x8, x8, #0xffffffffffffffe0
; CHECK-NEXT:    mov sp, x8
; CHECK-NEXT:    str x8, [x1]
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    ldr x19, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    ldp x29, x30, [sp], #32 // 16-byte Folded Reload
; CHECK-NEXT:  .LBB10_2: // %bb1
; CHECK-NEXT:    ret
;
; CHECK-MACHO-LABEL: realign_conditional2:
; CHECK-MACHO:       ; %bb.0: ; %entry
; CHECK-MACHO-NEXT:    tbz w0, #0, LBB10_2
; CHECK-MACHO-NEXT:  ; %bb.1: ; %bb0
; CHECK-MACHO-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill
; CHECK-MACHO-NEXT:    add x29, sp, #16
; CHECK-MACHO-NEXT:    sub x9, sp, #32
; CHECK-MACHO-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-MACHO-NEXT:    mov x19, sp
; CHECK-MACHO-NEXT:    .cfi_def_cfa w29, 16
; CHECK-MACHO-NEXT:    .cfi_offset w30, -8
; CHECK-MACHO-NEXT:    .cfi_offset w29, -16
; CHECK-MACHO-NEXT:    .cfi_offset w19, -24
; CHECK-MACHO-NEXT:    .cfi_offset w20, -32
; CHECK-MACHO-NEXT:    sub x8, sp, #64
; CHECK-MACHO-NEXT:    and x8, x8, #0xffffffffffffffe0
; CHECK-MACHO-NEXT:    mov sp, x8
; CHECK-MACHO-NEXT:    str x8, [x1]
; CHECK-MACHO-NEXT:    sub sp, x29, #16
; CHECK-MACHO-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload
; CHECK-MACHO-NEXT:  LBB10_2: ; %bb1
; CHECK-MACHO-NEXT:    ret
entry:
  %tmp = alloca i8, i32 16
  br i1 %b, label %bb0, label %bb1
bb0:
  %MyAlloca = alloca i8, i64 64, align 32
  store ptr %MyAlloca, ptr %p
  br label %bb1
bb1:
  ret void
}
; Extra realignment in the prologue (performance issue).
; Stack is realigned in a non-entry BB.
attributes #0 = { "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
!1 = !{!2, !2, i64 0}
!2 = !{!"int", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
