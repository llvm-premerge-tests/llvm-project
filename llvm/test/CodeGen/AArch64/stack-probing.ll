; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple aarch64-none-eabi < %s -verify-machineinstrs -enable-post-misched=false | FileCheck %s
; RUN: llc -mtriple aarch64-none-eabi < %s -verify-machineinstrs -enable-post-misched=false -global-isel | FileCheck %s

; Tests for prolog sequences for stack probing, when using a 4KiB stack guard.

; Small stack frame, no probing required.
define void @static_64(i8** %out) #0 {
; CHECK-LABEL: static_64:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #64
; CHECK-NEXT:    .cfi_def_cfa_offset 64
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #64
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 64, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; At 256 bytes we start to always create a frame pointer. No frame smaller then
; this needs a probe, so we can use the saving of at least one CSR as a probe
; at the top of our frame.
define void @static_256(i8** %out) #0 {
; CHECK-LABEL: static_256:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #272
; CHECK-NEXT:    .cfi_def_cfa_offset 272
; CHECK-NEXT:    str x29, [sp, #256] // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #272
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 256, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; At 1024 bytes, this is the largest frame which doesn't need probing.
define void @static_1024(i8** %out) #0 {
; CHECK-LABEL: static_1024:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub sp, sp, #1024
; CHECK-NEXT:    .cfi_def_cfa_offset 1040
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #1024
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 1024, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; At 1024+16 bytes, this is the smallest frame which needs probing.
define void @static_1040(i8** %out) #0 {
; CHECK-LABEL: static_1040:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub sp, sp, #1040
; CHECK-NEXT:    .cfi_def_cfa_offset 1056
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #1040
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 1040, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 4k bytes is the largest frame we can probe in one go.
define void @static_4096(i8** %out) #0 {
; CHECK-LABEL: static_4096:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 4112
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 4096, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 4k+16 bytes, still needs just one probe.
define void @static_4112(i8** %out) #0 {
; CHECK-LABEL: static_4112:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 4112
; CHECK-NEXT:    str xzr, [sp], #-16
; CHECK-NEXT:    .cfi_def_cfa_offset 4128
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    add sp, sp, #16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 4112, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 4k+1024 bytes, the largest frame which needs just one probe.
define void @static_5120(i8** %out) #0 {
; CHECK-LABEL: static_5120:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 4112
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    sub sp, sp, #1024
; CHECK-NEXT:    .cfi_def_cfa_offset 5136
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 1040
; CHECK-NEXT:    add sp, sp, #1024
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 5120, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 4k+1024+16, the smallest frame which needs two probes.
define void @static_5136(i8** %out) #0 {
; CHECK-LABEL: static_5136:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 4112
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    sub sp, sp, #1040
; CHECK-NEXT:    .cfi_def_cfa_offset 5152
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 1056
; CHECK-NEXT:    add sp, sp, #1040
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 5136, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 2*4k+1024, the largest frame needing two probes
define void @static_9216(i8** %out) #0 {
; CHECK-LABEL: static_9216:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 4112
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 8208
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    sub sp, sp, #1024
; CHECK-NEXT:    .cfi_def_cfa_offset 9232
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #2, lsl #12 // =8192
; CHECK-NEXT:    .cfi_def_cfa_offset 1040
; CHECK-NEXT:    add sp, sp, #1024
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 9216, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 4*4k-16, the largest frame probed without a loop
define void @static_16368(i8** %out) #0 {
; CHECK-LABEL: static_16368:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 4112
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 8208
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    .cfi_def_cfa_offset 12304
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    sub sp, sp, #4080
; CHECK-NEXT:    .cfi_def_cfa_offset 16384
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #3, lsl #12 // =12288
; CHECK-NEXT:    .cfi_def_cfa_offset 4096
; CHECK-NEXT:    add sp, sp, #4080
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 16368, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 4*4k, the smallest frame probed with a loop
define void @static_16384(i8** %out) #0 {
; CHECK-LABEL: static_16384:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub x9, sp, #4, lsl #12 // =16384
; CHECK-NEXT:    .cfi_def_cfa w9, 16400
; CHECK-NEXT:  .LBB10_1: // %entry
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    cmp sp, x9
; CHECK-NEXT:    b.ne .LBB10_1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    .cfi_def_cfa_register wsp
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #4, lsl #12 // =16384
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 16384, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 4*4k + 1024, large enough to use a loop, but not a multiple of 4KiB
; so has a reminder, but no extra probe.
define void @static_17408(i8** %out) #0 {
; CHECK-LABEL: static_17408:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub x9, sp, #4, lsl #12 // =16384
; CHECK-NEXT:    .cfi_def_cfa w9, 16400
; CHECK-NEXT:  .LBB11_1: // %entry
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    cmp sp, x9
; CHECK-NEXT:    b.ne .LBB11_1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    .cfi_def_cfa_register wsp
; CHECK-NEXT:    sub sp, sp, #1024
; CHECK-NEXT:    .cfi_def_cfa_offset 17424
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #4, lsl #12 // =16384
; CHECK-NEXT:    .cfi_def_cfa_offset 1040
; CHECK-NEXT:    add sp, sp, #1024
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 17408, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; 4*4k+1040, large enough to use a loop, has a reminder and
; an extra probe.
define void @static_17424(i8** %out) #0 {
; CHECK-LABEL: static_17424:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    str x29, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub x9, sp, #4, lsl #12 // =16384
; CHECK-NEXT:    .cfi_def_cfa w9, 16400
; CHECK-NEXT:  .LBB12_1: // %entry
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    cmp sp, x9
; CHECK-NEXT:    b.ne .LBB12_1
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    .cfi_def_cfa_register wsp
; CHECK-NEXT:    sub sp, sp, #1040
; CHECK-NEXT:    .cfi_def_cfa_offset 17440
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    add sp, sp, #4, lsl #12 // =16384
; CHECK-NEXT:    .cfi_def_cfa_offset 1056
; CHECK-NEXT:    add sp, sp, #1040
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    ldr x29, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 17424, align 1
  store i8* %vla, i8** %out, align 8
  ret void
}

; A small allocation, but with a very large alignment requirement. We do this
; by moving SP far enough that a sufficiently-aligned block will exist
; somewhere in the stack frame, so must probe the whole of that larger SP move.
define void @static_16_align_8192(i8** %out) #0 {
; CHECK-LABEL: static_16_align_8192:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .cfi_def_cfa w29, 16
; CHECK-NEXT:    .cfi_offset w30, -8
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub x9, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    sub x9, x9, #4080
; CHECK-NEXT:    and x9, x9, #0xffffffffffffe000
; CHECK-NEXT:  .LBB13_1: // %entry
; CHECK-NEXT:    // =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sub sp, sp, #1, lsl #12 // =4096
; CHECK-NEXT:    cmp sp, x9
; CHECK-NEXT:    b.le .LBB13_3
; CHECK-NEXT:  // %bb.2: // %entry
; CHECK-NEXT:    // in Loop: Header=BB13_1 Depth=1
; CHECK-NEXT:    str xzr, [sp]
; CHECK-NEXT:    b .LBB13_1
; CHECK-NEXT:  .LBB13_3: // %entry
; CHECK-NEXT:    str xzr, [x9]
; CHECK-NEXT:    mov sp, x9
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .cfi_def_cfa wsp, 16
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 16, align 8192
  store i8* %vla, i8** %out, align 8
  ret void
}

; A small allocation with a very large alignment requirement, but
; nevertheless small enough as to not need a loop.
define void @static_16_align_2048(i8** %out) #0 {
; CHECK-LABEL: static_16_align_2048:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .cfi_def_cfa w29, 16
; CHECK-NEXT:    .cfi_offset w30, -8
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub x9, sp, #2032
; CHECK-NEXT:    and x9, x9, #0xfffffffffffff800
; CHECK-NEXT:    str xzr, [x9]
; CHECK-NEXT:    mov sp, x9
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .cfi_def_cfa wsp, 16
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 16, align 2048
  store i8* %vla, i8** %out, align 8
  ret void
}

; A large(-ish) allocation with a very large alignment requirement, but
; nevertheless small enough as to not need a loop.
define void @static_2032_align_2048(i8** %out) #0 {
; CHECK-LABEL: static_2032_align_2048:
; CHECK:       // %bb.0: // %entry
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    mov x29, sp
; CHECK-NEXT:    .cfi_def_cfa w29, 16
; CHECK-NEXT:    .cfi_offset w30, -8
; CHECK-NEXT:    .cfi_offset w29, -16
; CHECK-NEXT:    sub x9, sp, #2032
; CHECK-NEXT:    and x9, x9, #0xfffffffffffff800
; CHECK-NEXT:    str xzr, [x9]
; CHECK-NEXT:    mov sp, x9
; CHECK-NEXT:    mov x8, sp
; CHECK-NEXT:    str x8, [x0]
; CHECK-NEXT:    mov sp, x29
; CHECK-NEXT:    .cfi_def_cfa wsp, 16
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    .cfi_restore w30
; CHECK-NEXT:    .cfi_restore w29
; CHECK-NEXT:    ret
entry:
  %vla = alloca i8, i64 2032, align 2048
  store i8* %vla, i8** %out, align 8
  ret void
}

attributes #0 = {uwtable(async) "probe-stack"="inline-asm" "frame-pointer"="none"}

