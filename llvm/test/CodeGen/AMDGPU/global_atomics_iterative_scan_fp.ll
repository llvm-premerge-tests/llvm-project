; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN:  opt -S -mtriple=amdgcn-- -amdgpu-atomic-optimizer-strategy=Iterative -passes='amdgpu-atomic-optimizer,verify<domtree>' %s | FileCheck -check-prefix=IR %s

declare i32 @llvm.amdgcn.workitem.id.x()
define amdgpu_kernel void @global_atomic_fadd_uni_value(ptr addrspace(1) %ptr) #0 {
; IR-LABEL: @global_atomic_fadd_uni_value(
; IR-NEXT:    [[TMP1:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; IR-NEXT:    [[TMP2:%.*]] = bitcast i64 [[TMP1]] to <2 x i32>
; IR-NEXT:    [[TMP3:%.*]] = extractelement <2 x i32> [[TMP2]], i32 0
; IR-NEXT:    [[TMP4:%.*]] = extractelement <2 x i32> [[TMP2]], i32 1
; IR-NEXT:    [[TMP5:%.*]] = call i32 @llvm.amdgcn.mbcnt.lo(i32 [[TMP3]], i32 0)
; IR-NEXT:    [[TMP6:%.*]] = call i32 @llvm.amdgcn.mbcnt.hi(i32 [[TMP4]], i32 [[TMP5]])
; IR-NEXT:    [[TMP7:%.*]] = call i64 @llvm.ctpop.i64(i64 [[TMP1]])
; IR-NEXT:    [[TMP8:%.*]] = trunc i64 [[TMP7]] to i32
; IR-NEXT:    [[TMP9:%.*]] = uitofp i32 [[TMP8]] to float
; IR-NEXT:    [[TMP10:%.*]] = fmul float 4.000000e+00, [[TMP9]]
; IR-NEXT:    [[TMP11:%.*]] = icmp eq i32 [[TMP6]], 0
; IR-NEXT:    br i1 [[TMP11]], label [[TMP12:%.*]], label [[TMP14:%.*]]
; IR:       12:
; IR-NEXT:    [[TMP13:%.*]] = atomicrmw fadd ptr addrspace(1) [[PTR:%.*]], float [[TMP10]] seq_cst, align 4
; IR-NEXT:    br label [[TMP14]]
; IR:       14:
; IR-NEXT:    ret void
;
  %result = atomicrmw fadd ptr addrspace(1) %ptr, float 4.0 seq_cst
  ret void
}


define amdgpu_kernel void @global_atomic_fadd_div_value(ptr addrspace(1) %ptr) #0 {
; IR-LABEL: @global_atomic_fadd_div_value(
; IR-NEXT:    [[ID_X:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; IR-NEXT:    [[DIVVALUE:%.*]] = bitcast i32 [[ID_X]] to float
; IR-NEXT:    [[TMP1:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; IR-NEXT:    [[TMP2:%.*]] = bitcast i64 [[TMP1]] to <2 x i32>
; IR-NEXT:    [[TMP3:%.*]] = extractelement <2 x i32> [[TMP2]], i32 0
; IR-NEXT:    [[TMP4:%.*]] = extractelement <2 x i32> [[TMP2]], i32 1
; IR-NEXT:    [[TMP5:%.*]] = call i32 @llvm.amdgcn.mbcnt.lo(i32 [[TMP3]], i32 0)
; IR-NEXT:    [[TMP6:%.*]] = call i32 @llvm.amdgcn.mbcnt.hi(i32 [[TMP4]], i32 [[TMP5]])
; IR-NEXT:    [[TMP7:%.*]] = call i64 @llvm.amdgcn.ballot.i64(i1 true)
; IR-NEXT:    br label [[COMPUTELOOP:%.*]]
; IR:       8:
; IR-NEXT:    [[TMP9:%.*]] = atomicrmw fadd ptr addrspace(1) [[PTR:%.*]], float [[TMP16:%.*]] seq_cst, align 4
; IR-NEXT:    br label [[TMP10:%.*]]
; IR:       10:
; IR-NEXT:    ret void
; IR:       ComputeLoop:
; IR-NEXT:    [[ACCUMULATOR:%.*]] = phi float [ 0.000000e+00, [[TMP0:%.*]] ], [ [[TMP16]], [[COMPUTELOOP]] ]
; IR-NEXT:    [[ACTIVEBITS:%.*]] = phi i64 [ [[TMP7]], [[TMP0]] ], [ [[TMP19:%.*]], [[COMPUTELOOP]] ]
; IR-NEXT:    [[TMP11:%.*]] = call i64 @llvm.cttz.i64(i64 [[ACTIVEBITS]], i1 true)
; IR-NEXT:    [[TMP12:%.*]] = trunc i64 [[TMP11]] to i32
; IR-NEXT:    [[TMP13:%.*]] = bitcast float [[DIVVALUE]] to i32
; IR-NEXT:    [[TMP14:%.*]] = call i32 @llvm.amdgcn.readlane(i32 [[TMP13]], i32 [[TMP12]])
; IR-NEXT:    [[TMP15:%.*]] = bitcast i32 [[TMP14]] to float
; IR-NEXT:    [[TMP16]] = fadd float [[ACCUMULATOR]], [[TMP15]]
; IR-NEXT:    [[TMP17:%.*]] = shl i64 1, [[TMP11]]
; IR-NEXT:    [[TMP18:%.*]] = xor i64 [[TMP17]], -1
; IR-NEXT:    [[TMP19]] = and i64 [[ACTIVEBITS]], [[TMP18]]
; IR-NEXT:    [[TMP20:%.*]] = icmp eq i64 [[TMP19]], 0
; IR-NEXT:    br i1 [[TMP20]], label [[COMPUTEEND:%.*]], label [[COMPUTELOOP]]
; IR:       ComputeEnd:
; IR-NEXT:    [[TMP21:%.*]] = icmp eq i32 [[TMP6]], 0
; IR-NEXT:    br i1 [[TMP21]], label [[TMP8:%.*]], label [[TMP10]]
;
  %id.x = call i32 @llvm.amdgcn.workitem.id.x()
  %divValue = bitcast i32 %id.x to float
  %result = atomicrmw fadd ptr addrspace(1) %ptr, float %divValue seq_cst
  ret void
}

attributes #0 = {"target-cpu"="gfx906"}
