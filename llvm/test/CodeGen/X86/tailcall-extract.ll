; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
; RUN: llc -mtriple=x86_64-linux < %s | FileCheck %s
; RUN: opt -codegenprepare -S -mtriple=x86_64-linux < %s | FileCheck %s --check-prefix OPT


; The exit block containing extractvalue can be duplicated into the BB
; containing call. And later tail call can be generated.

; OPT-LABEL:   test1
; OPT:         if.then.i:
; OPT-NEXT:    tail call { ptr, i64 } @bar
; OPT-NEXT:    extractvalue
; OPT-NEXT:    ret
;
; OPT:         if.end.i:
; OPT-NEXT:    tail call { ptr, i64 } @foo
; OPT-NEXT:    extractvalue
; OPT-NEXT:    ret

define ptr @test1(i64 %size) {
; CHECK-LABEL: test1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq $16385, %rdi # imm = 0x4001
; CHECK-NEXT:    setae %al
; CHECK-NEXT:    leaq 7(%rdi), %rcx
; CHECK-NEXT:    shrq $3, %rcx
; CHECK-NEXT:    testl %ecx, %ecx
; CHECK-NEXT:    sete %cl
; CHECK-NEXT:    orb %al, %cl
; CHECK-NEXT:    jne foo # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.then.i
; CHECK-NEXT:    jmp bar # TAILCALL
entry:
  %cmp.i.i = icmp ugt i64 %size, 16384
  %add.i.i = add i64 %size, 7
  %div.i.i = lshr i64 %add.i.i, 3
  %phitmp.i.i = trunc i64 %div.i.i to i32
  %cmp1.i = icmp eq i32 %phitmp.i.i, 0
  %cmp.i = or i1 %cmp.i.i, %cmp1.i
  br i1 %cmp.i, label %if.end.i, label %if.then.i
  if.then.i:                                        ; preds = %entry
  %call1.i = tail call { ptr, i64 } @bar(i64 %size)
  br label %exit

if.end.i:                                         ; preds = %entry
  %call2.i = tail call { ptr, i64 } @foo(i64 %size)
  br label %exit

exit:
  %call1.i.sink = phi { ptr, i64 } [ %call1.i, %if.then.i ], [ %call2.i, %if.end.i ]
  %ev = extractvalue { ptr, i64 } %call1.i.sink, 0
  ret ptr %ev
}


; The extractvalue extracts a field with non-zero offset, so the exit block
; can't be duplicated.

; OPT-LABEL:   test2
; OPT:         if.then.i:
; OPT-NEXT:    tail call { ptr, i64 } @bar
; OPT-NEXT:    br label %exit
;
; OPT:         if.end.i:
; OPT-NEXT:    tail call { ptr, i64 } @foo
; OPT-NEXT:    br label %exit
;
; OPT:         exit:
; OPT-NEXT:    phi
; OPT-NEXT:    extractvalue
; OPT-NEXT:    ret

define i64 @test2(i64 %size) {
; CHECK-LABEL: test2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    cmpq $16385, %rdi # imm = 0x4001
; CHECK-NEXT:    setae %al
; CHECK-NEXT:    leaq 7(%rdi), %rcx
; CHECK-NEXT:    shrq $3, %rcx
; CHECK-NEXT:    testl %ecx, %ecx
; CHECK-NEXT:    sete %cl
; CHECK-NEXT:    orb %al, %cl
; CHECK-NEXT:    je .LBB1_1
; CHECK-NEXT:  # %bb.2: # %if.end.i
; CHECK-NEXT:    callq foo
; CHECK-NEXT:    jmp .LBB1_3
; CHECK-NEXT:  .LBB1_1: # %if.then.i
; CHECK-NEXT:    callq bar
; CHECK-NEXT:  .LBB1_3: # %exit
; CHECK-NEXT:    movq %rdx, %rax
; CHECK-NEXT:    popq %rcx
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
entry:
  %cmp.i.i = icmp ugt i64 %size, 16384
  %add.i.i = add i64 %size, 7
  %div.i.i = lshr i64 %add.i.i, 3
  %phitmp.i.i = trunc i64 %div.i.i to i32
  %cmp1.i = icmp eq i32 %phitmp.i.i, 0
  %cmp.i = or i1 %cmp.i.i, %cmp1.i
  br i1 %cmp.i, label %if.end.i, label %if.then.i
  if.then.i:                                        ; preds = %entry
  %call1.i = tail call { ptr, i64 } @bar(i64 %size)
  br label %exit

if.end.i:                                         ; preds = %entry
  %call2.i = tail call { ptr, i64 } @foo(i64 %size)
  br label %exit

exit:
  %call1.i.sink = phi { ptr, i64 } [ %call1.i, %if.then.i ], [ %call2.i, %if.end.i ]
  %ev = extractvalue { ptr, i64 } %call1.i.sink, 1
  ret i64 %ev
}


; The extractvalue accesses a nest struct type, the extracted field has zero
; offset, so the exit block can still be duplicated, and tail call generated.

; OPT-LABEL:   test3
; OPT:         if.then.i:
; OPT-NEXT:    tail call { { ptr, i64 }, i64 } @baz
; OPT-NEXT:    extractvalue
; OPT-NEXT:    ret
;
; OPT:         if.end.i:
; OPT-NEXT:    tail call { { ptr, i64 }, i64 } @qux
; OPT-NEXT:    extractvalue
; OPT-NEXT:    ret

define ptr @test3(i64 %size) {
; CHECK-LABEL: test3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmpq $16385, %rdi # imm = 0x4001
; CHECK-NEXT:    setae %al
; CHECK-NEXT:    leaq 7(%rdi), %rcx
; CHECK-NEXT:    shrq $3, %rcx
; CHECK-NEXT:    testl %ecx, %ecx
; CHECK-NEXT:    sete %cl
; CHECK-NEXT:    orb %al, %cl
; CHECK-NEXT:    jne qux # TAILCALL
; CHECK-NEXT:  # %bb.1: # %if.then.i
; CHECK-NEXT:    jmp baz # TAILCALL
entry:
  %cmp.i.i = icmp ugt i64 %size, 16384
  %add.i.i = add i64 %size, 7
  %div.i.i = lshr i64 %add.i.i, 3
  %phitmp.i.i = trunc i64 %div.i.i to i32
  %cmp1.i = icmp eq i32 %phitmp.i.i, 0
  %cmp.i = or i1 %cmp.i.i, %cmp1.i
  br i1 %cmp.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %call1.i = tail call { {ptr, i64}, i64 } @baz(i64 %size)
  br label %exit

if.end.i:                                         ; preds = %entry
  %call2.i = tail call { {ptr, i64}, i64 } @qux(i64 %size)
  br label %exit

exit:
  %call1.i.sink = phi { {ptr, i64}, i64 } [ %call1.i, %if.then.i ], [ %call2.i, %if.end.i ]
  %ev = extractvalue { {ptr, i64}, i64 } %call1.i.sink, 0, 0
  ret ptr %ev
}


; The extractvalue accesses a nest struct with non-zero offset, so the exit
; block can't be duplicated.

; OPT-LABEL:   test4
; OPT:         if.then.i:
; OPT-NEXT:    tail call { { ptr, i64 }, i64 } @baz
; OPT-NEXT:    br label %exit
;
; OPT:         if.end.i:
; OPT-NEXT:    tail call { { ptr, i64 }, i64 } @qux
; OPT-NEXT:    br label %exit
;
; OPT:         exit:
; OPT-NEXT:    phi
; OPT-NEXT:    extractvalue
; OPT-NEXT:    ret

define i64 @test4(i64 %size) {
; CHECK-LABEL: test4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    pushq %rax
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    cmpq $16385, %rdi # imm = 0x4001
; CHECK-NEXT:    setae %al
; CHECK-NEXT:    leaq 7(%rdi), %rcx
; CHECK-NEXT:    shrq $3, %rcx
; CHECK-NEXT:    testl %ecx, %ecx
; CHECK-NEXT:    sete %cl
; CHECK-NEXT:    orb %al, %cl
; CHECK-NEXT:    je .LBB3_1
; CHECK-NEXT:  # %bb.2: # %if.end.i
; CHECK-NEXT:    callq qux
; CHECK-NEXT:    jmp .LBB3_3
; CHECK-NEXT:  .LBB3_1: # %if.then.i
; CHECK-NEXT:    callq baz
; CHECK-NEXT:  .LBB3_3: # %exit
; CHECK-NEXT:    movq %rdx, %rax
; CHECK-NEXT:    popq %rcx
; CHECK-NEXT:    .cfi_def_cfa_offset 8
; CHECK-NEXT:    retq
entry:
  %cmp.i.i = icmp ugt i64 %size, 16384
  %add.i.i = add i64 %size, 7
  %div.i.i = lshr i64 %add.i.i, 3
  %phitmp.i.i = trunc i64 %div.i.i to i32
  %cmp1.i = icmp eq i32 %phitmp.i.i, 0
  %cmp.i = or i1 %cmp.i.i, %cmp1.i
  br i1 %cmp.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %call1.i = tail call { {ptr, i64}, i64 } @baz(i64 %size)
  br label %exit

if.end.i:                                         ; preds = %entry
  %call2.i = tail call { {ptr, i64}, i64 } @qux(i64 %size)
  br label %exit

exit:
  %call1.i.sink = phi { {ptr, i64}, i64 } [ %call1.i, %if.then.i ], [ %call2.i, %if.end.i ]
  %ev = extractvalue { {ptr, i64}, i64 } %call1.i.sink, 0, 1
  ret i64 %ev
}


declare dso_local { ptr, i64 } @foo(i64)
declare dso_local { ptr, i64 } @bar(i64)
declare dso_local { {ptr, i64}, i64 } @baz(i64)
declare dso_local { {ptr, i64}, i64 } @qux(i64)
