; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=loop-vectorize -enable-boscc-vectorization -S %s | FileCheck %s
;
;  for (unsigned i = 0; i < len; i++) {
;    if (X[i]) {
;      A[i] = B[i] + C[i];
;      if (Y[i])
;        D[i] = E[i] * F[i];
;    }
;  }
;

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: argmemonly nofree norecurse nosync nounwind uwtable
define dso_local void @foo(ptr noalias %A, ptr %B, ptr %C, ptr noalias %D, ptr %E, ptr %F, ptr %X, ptr %Y, i32 noundef %len) local_unnamed_addr #0 {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP27_NOT:%.*]] = icmp eq i32 [[LEN:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP27_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY_PREHEADER:%.*]]
; CHECK:       for.body.preheader:
; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[LEN]] to i64
; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[WIDE_TRIP_COUNT]], 8
; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]
; CHECK:       vector.ph:
; CHECK-NEXT:    [[N_MOD_VF:%.*]] = urem i64 [[WIDE_TRIP_COUNT]], 8
; CHECK-NEXT:    [[N_VEC:%.*]] = sub i64 [[WIDE_TRIP_COUNT]], [[N_MOD_VF]]
; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
; CHECK:       vector.body:
; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[IF_THEN10_BOSCC_JOIN:%.*]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = add i64 [[INDEX]], 0
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr [[X:%.*]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i32 0
; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <8 x i32>, ptr [[TMP2]], align 4, !tbaa [[TBAA5:![0-9]+]]
; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq <8 x i32> [[WIDE_LOAD]], zeroinitializer
; CHECK-NEXT:    br label [[IF_THEN_BOSCC_GUARD:%.*]]
; CHECK:       if.then.boscc.guard:
; CHECK-NEXT:    [[TMP4:%.*]] = xor <8 x i1> [[TMP3]], <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    [[TMP5:%.*]] = bitcast <8 x i1> [[TMP4]] to i8
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ne i8 [[TMP5]], 0
; CHECK-NEXT:    br i1 [[TMP6]], label [[IF_THEN_BOSCC:%.*]], label [[IF_THEN_BOSCC_JOIN:%.*]]
; CHECK:       if.then.boscc:
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i32, ptr [[B:%.*]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i32, ptr [[TMP7]], i32 0
; CHECK-NEXT:    [[WIDE_MASKED_LOAD:%.*]] = call <8 x i32> @llvm.masked.load.v8i32.p0(ptr [[TMP8]], i32 4, <8 x i1> [[TMP4]], <8 x i32> poison), !tbaa [[TBAA5]]
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i32, ptr [[C:%.*]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i32, ptr [[TMP9]], i32 0
; CHECK-NEXT:    [[WIDE_MASKED_LOAD1:%.*]] = call <8 x i32> @llvm.masked.load.v8i32.p0(ptr [[TMP10]], i32 4, <8 x i1> [[TMP4]], <8 x i32> poison), !tbaa [[TBAA5]]
; CHECK-NEXT:    [[TMP11:%.*]] = add nsw <8 x i32> [[WIDE_MASKED_LOAD1]], [[WIDE_MASKED_LOAD]]
; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr i32, ptr [[A:%.*]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i32, ptr [[TMP12]], i32 0
; CHECK-NEXT:    call void @llvm.masked.store.v8i32.p0(<8 x i32> [[TMP11]], ptr [[TMP13]], i32 4, <8 x i1> [[TMP4]]), !tbaa [[TBAA5]]
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr i32, ptr [[Y:%.*]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr i32, ptr [[TMP14]], i32 0
; CHECK-NEXT:    [[WIDE_MASKED_LOAD2:%.*]] = call <8 x i32> @llvm.masked.load.v8i32.p0(ptr [[TMP15]], i32 4, <8 x i1> [[TMP4]], <8 x i32> poison), !tbaa [[TBAA5]]
; CHECK-NEXT:    [[TMP16:%.*]] = icmp eq <8 x i32> [[WIDE_MASKED_LOAD2]], zeroinitializer
; CHECK-NEXT:    br label [[IF_THEN_BOSCC_VEC_CONTINUE:%.*]]
; CHECK:       if.then.boscc.vec.continue:
; CHECK-NEXT:    br label [[IF_THEN_BOSCC_JOIN]]
; CHECK:       if.then.boscc.join:
; CHECK-NEXT:    [[TMP17:%.*]] = phi <8 x i1> [ [[TMP16]], [[IF_THEN_BOSCC_VEC_CONTINUE]] ], [ poison, [[IF_THEN_BOSCC_GUARD]] ]
; CHECK-NEXT:    br label [[IF_THEN10_BOSCC_GUARD:%.*]]
; CHECK:       if.then10.boscc.guard:
; CHECK-NEXT:    [[TMP18:%.*]] = xor <8 x i1> [[TMP17]], <i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true, i1 true>
; CHECK-NEXT:    [[TMP19:%.*]] = select <8 x i1> [[TMP4]], <8 x i1> [[TMP18]], <8 x i1> zeroinitializer
; CHECK-NEXT:    [[TMP20:%.*]] = bitcast <8 x i1> [[TMP19]] to i8
; CHECK-NEXT:    [[TMP21:%.*]] = icmp ne i8 [[TMP20]], 0
; CHECK-NEXT:    br i1 [[TMP21]], label [[IF_THEN10_BOSCC:%.*]], label [[IF_THEN10_BOSCC_JOIN]]
; CHECK:       if.then10.boscc:
; CHECK-NEXT:    [[TMP22:%.*]] = getelementptr i32, ptr [[E:%.*]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP23:%.*]] = getelementptr i32, ptr [[TMP22]], i32 0
; CHECK-NEXT:    [[WIDE_MASKED_LOAD3:%.*]] = call <8 x i32> @llvm.masked.load.v8i32.p0(ptr [[TMP23]], i32 4, <8 x i1> [[TMP19]], <8 x i32> poison), !tbaa [[TBAA5]]
; CHECK-NEXT:    [[TMP24:%.*]] = getelementptr i32, ptr [[F:%.*]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr i32, ptr [[TMP24]], i32 0
; CHECK-NEXT:    [[WIDE_MASKED_LOAD4:%.*]] = call <8 x i32> @llvm.masked.load.v8i32.p0(ptr [[TMP25]], i32 4, <8 x i1> [[TMP19]], <8 x i32> poison), !tbaa [[TBAA5]]
; CHECK-NEXT:    [[TMP26:%.*]] = mul nsw <8 x i32> [[WIDE_MASKED_LOAD4]], [[WIDE_MASKED_LOAD3]]
; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr i32, ptr [[D:%.*]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP28:%.*]] = getelementptr i32, ptr [[TMP27]], i32 0
; CHECK-NEXT:    call void @llvm.masked.store.v8i32.p0(<8 x i32> [[TMP26]], ptr [[TMP28]], i32 4, <8 x i1> [[TMP19]]), !tbaa [[TBAA5]]
; CHECK-NEXT:    br label [[IF_THEN10_BOSCC_VEC_CONTINUE:%.*]]
; CHECK:       if.then10.boscc.vec.continue:
; CHECK-NEXT:    br label [[IF_THEN10_BOSCC_JOIN]]
; CHECK:       if.then10.boscc.join:
; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 8
; CHECK-NEXT:    [[TMP29:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[TMP29]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP9:![0-9]+]]
; CHECK:       middle.block:
; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]
; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP_LOOPEXIT:%.*]], label [[SCALAR_PH]]
; CHECK:       scalar.ph:
; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ]
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup.loopexit:
; CHECK-NEXT:    br label [[FOR_COND_CLEANUP]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret void
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC:%.*]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[X]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP30:%.*]] = load i32, ptr [[ARRAYIDX]], align 4, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[TOBOOL_NOT:%.*]] = icmp eq i32 [[TMP30]], 0
; CHECK-NEXT:    br i1 [[TOBOOL_NOT]], label [[FOR_INC]], label [[IF_THEN:%.*]]
; CHECK:       if.then:
; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[B]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP31:%.*]] = load i32, ptr [[ARRAYIDX2]], align 4, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i32, ptr [[C]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP32:%.*]] = load i32, ptr [[ARRAYIDX4]], align 4, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP32]], [[TMP31]]
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i32, ptr [[A]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX6]], align 4, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds i32, ptr [[Y]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP33:%.*]] = load i32, ptr [[ARRAYIDX8]], align 4, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[TOBOOL9_NOT:%.*]] = icmp eq i32 [[TMP33]], 0
; CHECK-NEXT:    br i1 [[TOBOOL9_NOT]], label [[FOR_INC]], label [[IF_THEN10:%.*]]
; CHECK:       if.then10:
; CHECK-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds i32, ptr [[E]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP34:%.*]] = load i32, ptr [[ARRAYIDX12]], align 4, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds i32, ptr [[F]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP35:%.*]] = load i32, ptr [[ARRAYIDX14]], align 4, !tbaa [[TBAA5]]
; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP35]], [[TMP34]]
; CHECK-NEXT:    [[ARRAYIDX16:%.*]] = getelementptr inbounds i32, ptr [[D]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    store i32 [[MUL]], ptr [[ARRAYIDX16]], align 4, !tbaa [[TBAA5]]
; CHECK-NEXT:    br label [[FOR_INC]]
; CHECK:       for.inc:
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP14:![0-9]+]]
;
entry:
  %cmp27.not = icmp eq i32 %len, 0
  br i1 %cmp27.not, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %len to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.inc, %entry
  ret void

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds i32, ptr %X, i64 %indvars.iv
  %0 = load i32, ptr %arrayidx, align 4, !tbaa !5
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %arrayidx2 = getelementptr inbounds i32, ptr %B, i64 %indvars.iv
  %1 = load i32, ptr %arrayidx2, align 4, !tbaa !5
  %arrayidx4 = getelementptr inbounds i32, ptr %C, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx4, align 4, !tbaa !5
  %add = add nsw i32 %2, %1
  %arrayidx6 = getelementptr inbounds i32, ptr %A, i64 %indvars.iv
  store i32 %add, ptr %arrayidx6, align 4, !tbaa !5
  %arrayidx8 = getelementptr inbounds i32, ptr %Y, i64 %indvars.iv
  %3 = load i32, ptr %arrayidx8, align 4, !tbaa !5
  %tobool9.not = icmp eq i32 %3, 0
  br i1 %tobool9.not, label %for.inc, label %if.then10

if.then10:                                        ; preds = %if.then
  %arrayidx12 = getelementptr inbounds i32, ptr %E, i64 %indvars.iv
  %4 = load i32, ptr %arrayidx12, align 4, !tbaa !5
  %arrayidx14 = getelementptr inbounds i32, ptr %F, i64 %indvars.iv
  %5 = load i32, ptr %arrayidx14, align 4, !tbaa !5
  %mul = mul nsw i32 %5, %4
  %arrayidx16 = getelementptr inbounds i32, ptr %D, i64 %indvars.iv
  store i32 %mul, ptr %arrayidx16, align 4, !tbaa !5
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then10, %if.then
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !llvm.loop !9
}

attributes #0 = { argmemonly nofree norecurse nosync nounwind uwtable "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="znver3" "target-features"="+adx,+aes,+avx,+avx2,+bmi,+bmi2,+clflushopt,+clwb,+clzero,+crc32,+cx16,+cx8,+f16c,+fma,+fsgsbase,+fxsr,+invpcid,+lzcnt,+mmx,+movbe,+mwaitx,+pclmul,+pku,+popcnt,+prfchw,+rdpid,+rdpru,+rdrnd,+rdseed,+sahf,+sha,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+sse4a,+ssse3,+vaes,+vpclmulqdq,+wbnoinvd,+x87,+xsave,+xsavec,+xsaveopt,+xsaves" }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"clang version 16.0.0 (https://github.com/llvm/llvm-project.git 1fa2019828caec1172382009d5327c265427af57)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = distinct !{!9, !10, !11}
!10 = !{!"llvm.loop.mustprogress"}
!11 = !{!"llvm.loop.unroll.disable"}
