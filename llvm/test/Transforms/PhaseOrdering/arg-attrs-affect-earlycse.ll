; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -O3 -print-before=speculative-execution -memssa-check-limit=1 -disable-output 2>&1 | FileCheck %s

; We would expect to see the "readonly" attribute for "arg0", and as a result, "%load6"
; will be CSEd in early-cse<memssa>. Note that speculative-execution is the pass
; immediately afrer early-cse<memssa> in the pipeline currently.

define void @arg_attrs_affect_earlycse(ptr noalias %arg0) {
; CHECK-LABEL: define void @arg_attrs_affect_earlycse
; CHECK-SAME: (ptr noalias nocapture readonly [[ARG0:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  bb0:
; CHECK-NEXT:    [[GETELEMENTPTR0:%.*]] = getelementptr inbounds i64, ptr [[ARG0]], i64 1
; CHECK-NEXT:    [[LOAD2:%.*]] = load i64, ptr [[GETELEMENTPTR0]], align 8
; CHECK-NEXT:    [[ICMP0:%.*]] = icmp ugt i64 [[LOAD2]], 7
; CHECK-NEXT:    call void @snork(i1 zeroext [[ICMP0]])
; CHECK-NEXT:    [[ICMP2:%.*]] = icmp ne i64 [[LOAD2]], 0
; CHECK-NEXT:    call void @snork(i1 zeroext [[ICMP2]])
; CHECK-NEXT:    ret void
;
bb0:
  %alloca0 = alloca ptr, align 8
  %alloca1 = alloca ptr, align 8
  %alloca2 = alloca i32, align 4
  %alloca3 = alloca ptr, align 1
  store ptr %arg0, ptr %alloca0, align 8
  %load0 = load ptr, ptr %alloca0, align 8
  store ptr %load0, ptr %alloca1, align 8
  %add0 = add i64 0, 1
  %mul0 = mul i64 %add0, 8
  %load1 = load ptr, ptr %alloca1, align 8
  %getelementptr0 = getelementptr inbounds i64, ptr %load1, i64 1
  %load2 = load i64, ptr %getelementptr0, align 8
  %icmp0 = icmp ugt i64 %mul0, %load2
  %select = select i1 %icmp0, i1 false, i1 true
  %zext = zext i1 %select to i8
  store i8 %zext, ptr %alloca3, align 1
  %udiv0 = udiv i32 undef, 8
  store i32 %udiv0, ptr %alloca2, align 4
  %load3 = load i32, ptr %alloca2, align 4
  %add1 = add i32 %load3, 14
  %icmp1 = icmp ult i32 %add1, 24
  br i1 %icmp1, label %bb1, label %bb2

  bb1:
  %load4 = load i8, ptr %alloca3, align 1
  %trunc0 = trunc i8 %load4 to i1
  %select0 = select i1 %trunc0, i1 true, i1 false
  br label %bb2

bb2:
  %phi0 = phi i1 [ false, %bb0 ], [ %select0, %bb1 ]
  call void @snork(i1 zeroext %phi0)
  %load5 = load ptr, ptr %alloca1, align 8
  %getelementptr1 = getelementptr inbounds i64, ptr %load5, i64 1
  %load6 = load i64, ptr %getelementptr1, align 8
  %icmp2 = icmp ult i64 0, %load6
  call void @snork(i1 zeroext %icmp2)
  ret void
}

declare void @snork(i1 %arg0)
