; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes=infer-alignment -S < %s | FileCheck %s

@x = external global <2 x i64>, align 16
@xx = external global [13 x <2 x i64>], align 16

; ------------------------------------------------------------------------------
; load instructions
; ------------------------------------------------------------------------------

define <2 x i64> @hem(i32 %i) {
; CHECK-LABEL: define <2 x i64> @hem
; CHECK-SAME: (i32 [[I:%.*]]) {
; CHECK-NEXT:    [[T:%.*]] = getelementptr <2 x i64>, ptr @x, i32 [[I]]
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i64>, ptr [[T]], align 16
; CHECK-NEXT:    ret <2 x i64> [[TMP1]]
;
  %t = getelementptr <2 x i64>, ptr @x, i32 %i
  %tmp1 = load <2 x i64>, ptr %t, align 1
  ret <2 x i64> %tmp1
}

define <2 x i64> @hem_2d(i32 %i, i32 %j) {
; CHECK-LABEL: define <2 x i64> @hem_2d
; CHECK-SAME: (i32 [[I:%.*]], i32 [[J:%.*]]) {
; CHECK-NEXT:    [[T:%.*]] = getelementptr [13 x <2 x i64>], ptr @xx, i32 [[I]], i32 [[J]]
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i64>, ptr [[T]], align 16
; CHECK-NEXT:    ret <2 x i64> [[TMP1]]
;
  %t = getelementptr [13 x <2 x i64>], ptr @xx, i32 %i, i32 %j
  %tmp1 = load <2 x i64>, ptr %t, align 1
  ret <2 x i64> %tmp1
}

; TODO: For non-byte-sized vectors, current implementation assumes there is
; padding to the next byte boundary between elements.
@foo = constant <2 x i4> <i4 u0x1, i4 u0x2>, align 8

define i4 @test_vector_load_i4() {
; CHECK-LABEL: define i4 @test_vector_load_i4() {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr @foo, i64 0
; CHECK-NEXT:    [[RES0:%.*]] = load i4, ptr [[PTR0]], align 8
; CHECK-NEXT:    ret i4 [[RES0]]
;
  %ptr0 = getelementptr i8, ptr @foo, i64 0
  %res0 = load i4, ptr %ptr0, align 1
  ret i4 %res0
}

; Check that we improve the alignment information.
; The base pointer is 16-byte aligned and we access the field at
; an offset of 8-byte.
; Every element in the @CallerInfos array is 16-byte aligned so
; any access from the following gep is 8-byte aligned.
%struct.CallerInfo = type { ptr, i32 }
@CallerInfos = global [128 x %struct.CallerInfo] zeroinitializer, align 16

define i32 @test_gep_in_struct(i64 %idx) {
; CHECK-LABEL: define i32 @test_gep_in_struct
; CHECK-SAME: (i64 [[IDX:%.*]]) {
; CHECK-NEXT:    [[NS7:%.*]] = getelementptr inbounds [128 x %struct.CallerInfo], ptr @CallerInfos, i64 0, i64 [[IDX]], i32 1
; CHECK-NEXT:    [[RES:%.*]] = load i32, ptr [[NS7]], align 8
; CHECK-NEXT:    ret i32 [[RES]]
;
  %NS7 = getelementptr inbounds [128 x %struct.CallerInfo], ptr @CallerInfos, i64 0, i64 %idx, i32 1
  %res = load i32, ptr %NS7, align 1
  ret i32 %res
}

; ------------------------------------------------------------------------------
; store instructions
; ------------------------------------------------------------------------------

define void @hem_store(i32 %i, <2 x i64> %y) {
; CHECK-LABEL: define void @hem_store
; CHECK-SAME: (i32 [[I:%.*]], <2 x i64> [[Y:%.*]]) {
; CHECK-NEXT:    [[T:%.*]] = getelementptr <2 x i64>, ptr @x, i32 [[I]]
; CHECK-NEXT:    store <2 x i64> [[Y]], ptr [[T]], align 16
; CHECK-NEXT:    ret void
;
  %t = getelementptr <2 x i64>, ptr @x, i32 %i
  store <2 x i64> %y, ptr %t, align 1
  ret void
}

define void @hem_2d_store(i32 %i, i32 %j, <2 x i64> %y) {
; CHECK-LABEL: define void @hem_2d_store
; CHECK-SAME: (i32 [[I:%.*]], i32 [[J:%.*]], <2 x i64> [[Y:%.*]]) {
; CHECK-NEXT:    [[T:%.*]] = getelementptr [13 x <2 x i64>], ptr @xx, i32 [[I]], i32 [[J]]
; CHECK-NEXT:    store <2 x i64> [[Y]], ptr [[T]], align 16
; CHECK-NEXT:    ret void
;
  %t = getelementptr [13 x <2 x i64>], ptr @xx, i32 %i, i32 %j
  store <2 x i64> %y, ptr %t, align 1
  ret void
}

@arst = addrspace(1) global [4 x ptr addrspace(2)] zeroinitializer

define void @test_evaluate_gep_as_ptrs_array(ptr addrspace(2) %B) {
; CHECK-LABEL: define void @test_evaluate_gep_as_ptrs_array
; CHECK-SAME: (ptr addrspace(2) [[B:%.*]]) {
; CHECK-NEXT:    [[A:%.*]] = getelementptr [4 x ptr addrspace(2)], ptr addrspace(1) @arst, i16 0, i16 2
; CHECK-NEXT:    store ptr addrspace(2) [[B]], ptr addrspace(1) [[A]], align 16
; CHECK-NEXT:    ret void
;
  %A = getelementptr [4 x ptr addrspace(2)], ptr addrspace(1) @arst, i16 0, i16 2
  store ptr addrspace(2) %B, ptr addrspace(1) %A
  ret void
}

; Constant folding should fix notionally out-of-bounds indices
; and add inbounds keywords.

%struct.X = type { [3 x i32], [3 x i32] }

@Y = internal global [3 x %struct.X] zeroinitializer

define void @frob() {
; CHECK-LABEL: define void @frob() {
; CHECK-NEXT:    store i32 1, ptr @Y, align 16
; CHECK-NEXT:    store i32 1, ptr getelementptr inbounds ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 1), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr inbounds ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 2), align 8
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 3), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 4), align 16
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 5), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 6), align 8
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 7), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 8), align 16
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 9), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 10), align 8
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 11), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 12), align 16
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 13), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 14), align 8
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 15), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 16), align 16
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 17), align 4
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 18), align 8
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 36), align 16
; CHECK-NEXT:    store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 19), align 8
; CHECK-NEXT:    ret void
;
  store i32 1, ptr @Y, align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 1), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 2), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 3), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 4), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 5), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 6), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 7), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 8), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 9), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 10), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 11), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 12), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 13), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 14), align 8
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 15), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 16), align 8
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 17), align 4
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 18), align 8
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 36), align 8
  store i32 1, ptr getelementptr ([3 x %struct.X], ptr @Y, i64 0, i64 0, i32 0, i64 19), align 8
  ret void
}
