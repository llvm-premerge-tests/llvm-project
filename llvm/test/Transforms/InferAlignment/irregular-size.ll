; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -passes=infer-alignment -S | FileCheck %s

define i177 @ossfuzz_9880(i177 %X) {
; CHECK-LABEL: define i177 @ossfuzz_9880
; CHECK-SAME: (i177 [[X:%.*]]) {
; CHECK-NEXT:    [[A:%.*]] = alloca i177, align 8
; CHECK-NEXT:    [[L1:%.*]] = load i177, ptr [[A]], align 8
; CHECK-NEXT:    ret i177 [[L1]]
;
  %A = alloca i177
  %L1 = load i177, ptr %A
  ret i177 %L1
}

; TODO: For non-byte-sized vectors, current implementation assumes there is
; padding to the next byte boundary between elements.
@vector_i4 = constant <2 x i4> <i4 u0x1, i4 u0x2>, align 8

define void @load_vector_i4() {
; CHECK-LABEL: define void @load_vector_i4() {
; CHECK-NEXT:    [[PTR0:%.*]] = getelementptr i8, ptr @vector_i4, i64 0
; CHECK-NEXT:    [[RES0:%.*]] = load i4, ptr [[PTR0]], align 8
; CHECK-NEXT:    ret void
;
  %ptr0 = getelementptr i8, ptr @vector_i4, i64 0
  %res0 = load i4, ptr %ptr0, align 1
  ret void
}
