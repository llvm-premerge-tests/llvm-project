; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -passes=no-op-function -S | FileCheck %s

define void @foo2(ptr %b, i64 %n, i64 %u, i64 %y) nounwind  {
; CHECK-LABEL: define void @foo2
; CHECK-SAME: (ptr [[B:%.*]], i64 [[N:%.*]], i64 [[U:%.*]], i64 [[Y:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[C:%.*]] = ptrtoint ptr [[B]] to i64
; CHECK-NEXT:    [[D:%.*]] = and i64 [[C]], -16
; CHECK-NEXT:    [[E:%.*]] = inttoptr i64 [[D]] to ptr
; CHECK-NEXT:    [[V:%.*]] = mul i64 [[U]], 2
; CHECK-NEXT:    [[Z:%.*]] = and i64 [[Y]], -2
; CHECK-NEXT:    [[T1421:%.*]] = icmp eq i64 [[N]], 0
; CHECK-NEXT:    br i1 [[T1421]], label [[RETURN:%.*]], label [[BB:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ [[INDVAR_NEXT:%.*]], [[BB]] ], [ 20, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[J:%.*]] = mul i64 [[I]], [[V]]
; CHECK-NEXT:    [[H:%.*]] = add i64 [[J]], [[Z]]
; CHECK-NEXT:    [[T8:%.*]] = getelementptr double, ptr [[E]], i64 [[H]]
; CHECK-NEXT:    store <2 x double> zeroinitializer, ptr [[T8]], align 8
; CHECK-NEXT:    [[INDVAR_NEXT]] = add i64 [[I]], 1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVAR_NEXT]], [[N]]
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[RETURN]], label [[BB]]
; CHECK:       return:
; CHECK-NEXT:    ret void
;
entry:
  %c = ptrtoint ptr %b to i64
  %d = and i64 %c, -16
  %e = inttoptr i64 %d to ptr
  %v = mul i64 %u, 2
  %z = and i64 %y, -2
  %t1421 = icmp eq i64 %n, 0
  br i1 %t1421, label %return, label %bb

bb:
  %i = phi i64 [ %indvar.next, %bb ], [ 20, %entry ]
  %j = mul i64 %i, %v
  %h = add i64 %j, %z
  %t8 = getelementptr double, ptr %e, i64 %h
  store <2 x double><double 0.0, double 0.0>, ptr %t8, align 8
  %indvar.next = add i64 %i, 1
  %exitcond = icmp eq i64 %indvar.next, %n
  br i1 %exitcond, label %return, label %bb

return:
  ret void
}

; A multi-dimensional array in a nested loop doing vector stores that
; aren't yet aligned. InferAlignment can understand the addressing in the
; Nice case to prove 16 byte alignment. In the Awkward case, the inner
; array dimension is not even, so the stores to it won't always be
; aligned. InferAlignment should prove alignment in exactly one of the two
; stores.

@Nice    = global [1001 x [20000 x double]] zeroinitializer, align 32
@Awkward = global [1001 x [20001 x double]] zeroinitializer, align 32

define void @foo() nounwind  {
; CHECK-LABEL: define void @foo
; CHECK-SAME: () #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[BB7_OUTER:%.*]]
; CHECK:       bb7.outer:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INDVAR_NEXT26:%.*]], [[BB11:%.*]] ]
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[J:%.*]] = phi i64 [ 0, [[BB7_OUTER]] ], [ [[INDVAR_NEXT:%.*]], [[BB1]] ]
; CHECK-NEXT:    [[T4:%.*]] = getelementptr [1001 x [20000 x double]], ptr @Nice, i64 0, i64 [[I]], i64 [[J]]
; CHECK-NEXT:    store <2 x double> zeroinitializer, ptr [[T4]], align 8
; CHECK-NEXT:    [[S4:%.*]] = getelementptr [1001 x [20001 x double]], ptr @Awkward, i64 0, i64 [[I]], i64 [[J]]
; CHECK-NEXT:    store <2 x double> zeroinitializer, ptr [[S4]], align 8
; CHECK-NEXT:    [[INDVAR_NEXT]] = add i64 [[J]], 2
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVAR_NEXT]], 556
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[BB11]], label [[BB1]]
; CHECK:       bb11:
; CHECK-NEXT:    [[INDVAR_NEXT26]] = add i64 [[I]], 1
; CHECK-NEXT:    [[EXITCOND27:%.*]] = icmp eq i64 [[INDVAR_NEXT26]], 991
; CHECK-NEXT:    br i1 [[EXITCOND27]], label [[RETURN_SPLIT:%.*]], label [[BB7_OUTER]]
; CHECK:       return.split:
; CHECK-NEXT:    ret void
;
entry:
  br label %bb7.outer

bb7.outer:
  %i = phi i64 [ 0, %entry ], [ %indvar.next26, %bb11 ]
  br label %bb1

bb1:
  %j = phi i64 [ 0, %bb7.outer ], [ %indvar.next, %bb1 ]

  %t4 = getelementptr [1001 x [20000 x double]], ptr @Nice, i64 0, i64 %i, i64 %j
  store <2 x double><double 0.0, double 0.0>, ptr %t4, align 8

  %s4 = getelementptr [1001 x [20001 x double]], ptr @Awkward, i64 0, i64 %i, i64 %j
  store <2 x double><double 0.0, double 0.0>, ptr %s4, align 8

  %indvar.next = add i64 %j, 2
  %exitcond = icmp eq i64 %indvar.next, 556
  br i1 %exitcond, label %bb11, label %bb1

bb11:
  %indvar.next26 = add i64 %i, 1
  %exitcond27 = icmp eq i64 %indvar.next26, 991
  br i1 %exitcond27, label %return.split, label %bb7.outer

return.split:
  ret void
}
