; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -passes=infer-alignment -S -data-layout="E-p:64:64:64-a0:0:8-f32:32:32-f64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-v64:64:64-v128:128:128" | FileCheck %s -check-prefixes=ALL,CHECK
; RUN: opt < %s -passes=infer-alignment -S -data-layout="E-p:32:32:32-a0:0:8-f32:32:32-f64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-v64:64:64-v128:128:128" | FileCheck %s -check-prefixes=ALL,P32
; RUN: opt < %s -passes=infer-alignment -S | FileCheck %s -check-prefixes=NODL

define void @test3() {
; ALL-LABEL: define void @test3() {
; ALL-NEXT:    [[A:%.*]] = alloca { i32 }, align 4
; ALL-NEXT:    [[B:%.*]] = getelementptr { i32 }, ptr [[A]], i32 0, i32 0
; ALL-NEXT:    store i32 123, ptr [[B]], align 4
; ALL-NEXT:    ret void
;
; NODL-LABEL: define void @test3() {
; NODL-NEXT:    [[A:%.*]] = alloca { i32 }, align 8
; NODL-NEXT:    [[B:%.*]] = getelementptr { i32 }, ptr [[A]], i32 0, i32 0
; NODL-NEXT:    store i32 123, ptr [[B]], align 8
; NODL-NEXT:    ret void
;
  %A = alloca { i32 }             ; <ptr> [#uses=1]
  %B = getelementptr { i32 }, ptr %A, i32 0, i32 0            ; <ptr> [#uses=1]
  store i32 123, ptr %B
  ret void
}

define void @test5() {
; CHECK-LABEL: define void @test5() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[A:%.*]] = alloca { i32 }, align 4
; CHECK-NEXT:    [[B:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[C:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 123, ptr [[A]], align 4
; CHECK-NEXT:    store ptr [[A]], ptr [[B]], align 8
; CHECK-NEXT:    store i32 123, ptr [[B]], align 8
; CHECK-NEXT:    store atomic i32 2, ptr [[A]] unordered, align 4
; CHECK-NEXT:    store atomic i32 3, ptr [[A]] release, align 4
; CHECK-NEXT:    store atomic i32 4, ptr [[A]] seq_cst, align 4
; CHECK-NEXT:    [[C_1:%.*]] = addrspacecast ptr [[C]] to ptr addrspace(1)
; CHECK-NEXT:    store i32 123, ptr addrspace(1) [[C_1]], align 4
; CHECK-NEXT:    ret void
;
; P32-LABEL: define void @test5() {
; P32-NEXT:  entry:
; P32-NEXT:    [[A:%.*]] = alloca { i32 }, align 4
; P32-NEXT:    [[B:%.*]] = alloca ptr, align 4
; P32-NEXT:    [[C:%.*]] = alloca i32, align 4
; P32-NEXT:    store i32 123, ptr [[A]], align 4
; P32-NEXT:    store ptr [[A]], ptr [[B]], align 4
; P32-NEXT:    store i32 123, ptr [[B]], align 4
; P32-NEXT:    store atomic i32 2, ptr [[A]] unordered, align 4
; P32-NEXT:    store atomic i32 3, ptr [[A]] release, align 4
; P32-NEXT:    store atomic i32 4, ptr [[A]] seq_cst, align 4
; P32-NEXT:    [[C_1:%.*]] = addrspacecast ptr [[C]] to ptr addrspace(1)
; P32-NEXT:    store i32 123, ptr addrspace(1) [[C_1]], align 4
; P32-NEXT:    ret void
;
; NODL-LABEL: define void @test5() {
; NODL-NEXT:  entry:
; NODL-NEXT:    [[A:%.*]] = alloca { i32 }, align 8
; NODL-NEXT:    [[B:%.*]] = alloca ptr, align 8
; NODL-NEXT:    [[C:%.*]] = alloca i32, align 4
; NODL-NEXT:    store i32 123, ptr [[A]], align 8
; NODL-NEXT:    store ptr [[A]], ptr [[B]], align 8
; NODL-NEXT:    store i32 123, ptr [[B]], align 8
; NODL-NEXT:    store atomic i32 2, ptr [[A]] unordered, align 8
; NODL-NEXT:    store atomic i32 3, ptr [[A]] release, align 8
; NODL-NEXT:    store atomic i32 4, ptr [[A]] seq_cst, align 8
; NODL-NEXT:    [[C_1:%.*]] = addrspacecast ptr [[C]] to ptr addrspace(1)
; NODL-NEXT:    store i32 123, ptr addrspace(1) [[C_1]], align 4
; NODL-NEXT:    ret void
;

entry:
  %a = alloca { i32 }
  %b = alloca ptr
  %c = alloca i32
  store i32 123, ptr %a
  store ptr %a, ptr %b
  store i32 123, ptr %b
  store atomic i32 2, ptr %a unordered, align 4
  store atomic i32 3, ptr %a release, align 4
  store atomic i32 4, ptr %a seq_cst, align 4
  %c.1 = addrspacecast ptr %c to ptr addrspace(1)
  store i32 123, ptr addrspace(1) %c.1
  ret void
}

declare void @f(ptr %p)

define void @test6() {
; ALL-LABEL: define void @test6() {
; ALL-NEXT:  entry:
; ALL-NEXT:    [[A:%.*]] = alloca { i32 }, align 4
; ALL-NEXT:    [[B:%.*]] = alloca i32, align 4
; ALL-NEXT:    store volatile i32 123, ptr [[A]], align 4
; ALL-NEXT:    tail call void @f(ptr [[B]])
; ALL-NEXT:    ret void
;
; NODL-LABEL: define void @test6() {
; NODL-NEXT:  entry:
; NODL-NEXT:    [[A:%.*]] = alloca { i32 }, align 8
; NODL-NEXT:    [[B:%.*]] = alloca i32, align 4
; NODL-NEXT:    store volatile i32 123, ptr [[A]], align 8
; NODL-NEXT:    tail call void @f(ptr [[B]])
; NODL-NEXT:    ret void
;

entry:
  %a = alloca { i32 }
  %b = alloca i32
  store volatile i32 123, ptr %a
  tail call void @f(ptr %b)
  ret void
}
