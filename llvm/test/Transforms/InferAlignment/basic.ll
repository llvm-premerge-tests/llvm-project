; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes=infer-alignment -S < %s | FileCheck %s

; ------------------------------------------------------------------------------
; Undef and null
; ------------------------------------------------------------------------------

define i32 @load_from_undef(ptr %P) {
; CHECK-LABEL: define i32 @load_from_undef
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    [[RET:%.*]] = load i32, ptr undef, align 4
; CHECK-NEXT:    ret i32 [[RET]]
;
  %ret = load i32, ptr undef
  ret i32 %ret
}

define i32 @load_from_null(ptr %P) {
; CHECK-LABEL: define i32 @load_from_null
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    [[RET:%.*]] = load i32, ptr null, align 4294967296
; CHECK-NEXT:    ret i32 [[RET]]
;
  %ret = load i32, ptr null
  ret i32 %ret
}

define void @store_into_undef(ptr %P) {
; CHECK-LABEL: define void @store_into_undef
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    store i32 123, ptr undef, align 4
; CHECK-NEXT:    ret void
;
  store i32 123, ptr undef
  ret void
}

define void @store_into_null(ptr %P) {
; CHECK-LABEL: define void @store_into_null
; CHECK-SAME: (ptr [[P:%.*]]) {
; CHECK-NEXT:    store i32 124, ptr null, align 4294967296
; CHECK-NEXT:    ret void
;
  store i32 124, ptr null
  ret void
}


; ------------------------------------------------------------------------------
; Scalar types
; ------------------------------------------------------------------------------

; This test must not have the store of %x forwarded to the load -- there is an
; intervening store of %y. However, the intervening store occurs with a different
; type and size and to a different pointer value. This is ensuring that none of
; those confuse the analysis into thinking that the second store does not alias
; the first.

define i8 @test1(i8 %x, i32 %y) {
; CHECK-LABEL: define i8 @test1
; CHECK-SAME: (i8 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:    [[ALLOC:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i8 [[X]], ptr [[ALLOC]], align 4
; CHECK-NEXT:    store i32 [[Y]], ptr [[ALLOC]], align 4
; CHECK-NEXT:    [[RET:%.*]] = load i8, ptr [[ALLOC]], align 4
; CHECK-NEXT:    ret i8 [[RET]]
;
  %alloc = alloca i32
  store i8 %x, ptr %alloc
  store i32 %y, ptr %alloc
  %ret = load i8, ptr %alloc
  ret i8 %ret
}

@test2_global = external global i32

; Same test as @test1 essentially, but using a global instead of an alloca.
define i8 @test2(i8 %x, i32 %y) {
; CHECK-LABEL: define i8 @test2
; CHECK-SAME: (i8 [[X:%.*]], i32 [[Y:%.*]]) {
; CHECK-NEXT:    store i8 [[X]], ptr @test2_global, align 4
; CHECK-NEXT:    store i32 [[Y]], ptr @test2_global, align 4
; CHECK-NEXT:    [[RET:%.*]] = load i8, ptr @test2_global, align 4
; CHECK-NEXT:    ret i8 [[RET]]
;
  store i8 %x, ptr @test2_global
  store i32 %y, ptr @test2_global
  %ret = load i8, ptr @test2_global
  ret i8 %ret
}
