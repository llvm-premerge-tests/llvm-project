; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -passes=no-op-function -S | FileCheck %s

declare ptr @llvm.ptrmask.p0.i64(ptr, i64)
declare ptr @llvm.ptrmask.p0.i32(ptr, i32)
declare ptr @llvm.ptrmask.p0.i128(ptr, i128)

; TODO: alignment is not inferred here
define <16 x i8> @ptrmask_align_unknown_ptr_align1(ptr align 1 %ptr, i64 %mask) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align_unknown_ptr_align1
; CHECK-SAME: (ptr align 1 [[PTR:%.*]], i64 [[MASK:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i64(ptr [[PTR]], i64 [[MASK]])
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i64(ptr %ptr, i64 %mask)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

define <16 x i8> @ptrmask_align_unknown_ptr_align8(ptr align 8 %ptr, i64 %mask) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align_unknown_ptr_align8
; CHECK-SAME: (ptr align 8 [[PTR:%.*]], i64 [[MASK:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i64(ptr [[PTR]], i64 [[MASK]])
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i64(ptr %ptr, i64 %mask)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

; Increase load align from 1 to 2
define <16 x i8> @ptrmask_align2_ptr_align1(ptr align 1 %ptr) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align2_ptr_align1
; CHECK-SAME: (ptr align 1 [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i64(ptr [[PTR]], i64 -2)
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i64(ptr %ptr, i64 -2)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

; Increase load align from 1 to 4
define <16 x i8> @ptrmask_align4_ptr_align1(ptr align 1 %ptr) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align4_ptr_align1
; CHECK-SAME: (ptr align 1 [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i64(ptr [[PTR]], i64 -4)
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i64(ptr %ptr, i64 -4)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

; Increase load align from 1 to 8
define <16 x i8> @ptrmask_align8_ptr_align1(ptr align 1 %ptr) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align8_ptr_align1
; CHECK-SAME: (ptr align 1 [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i64(ptr [[PTR]], i64 -8)
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i64(ptr %ptr, i64 -8)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

; Underlying alignment already the same as forced alignment by ptrmask
; TODO: Should be able to drop the ptrmask
define <16 x i8> @ptrmask_align8_ptr_align8(ptr align 8 %ptr) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align8_ptr_align8
; CHECK-SAME: (ptr align 8 [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i64(ptr [[PTR]], i64 -8)
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i64(ptr %ptr, i64 -8)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

; Underlying alignment greater than alignment forced by ptrmask
; TODO: Should be able to drop the ptrmask
define <16 x i8> @ptrmask_align8_ptr_align16(ptr align 16 %ptr) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align8_ptr_align16
; CHECK-SAME: (ptr align 16 [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i64(ptr [[PTR]], i64 -8)
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i64(ptr %ptr, i64 -8)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

; Increase load align from 1 to 8, and the mask type is smaller
; than the pointer size.
define <16 x i8> @ptrmask_align8_ptr_align1_smallmask(ptr align 1 %ptr) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align8_ptr_align1_smallmask
; CHECK-SAME: (ptr align 1 [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i32(ptr [[PTR]], i32 -8)
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i32(ptr %ptr, i32 -8)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

; Increase load align from 1 to 8, and the mask type is larger
; than the pointer size.
define <16 x i8> @ptrmask_align8_ptr_align1_bigmask(ptr align 1 %ptr) {
; CHECK-LABEL: define <16 x i8> @ptrmask_align8_ptr_align1_bigmask
; CHECK-SAME: (ptr align 1 [[PTR:%.*]]) {
; CHECK-NEXT:    [[ALIGNED:%.*]] = call ptr @llvm.ptrmask.p0.i128(ptr [[PTR]], i128 -8)
; CHECK-NEXT:    [[LOAD:%.*]] = load <16 x i8>, ptr [[ALIGNED]], align 1
; CHECK-NEXT:    ret <16 x i8> [[LOAD]]
;
  %aligned = call ptr @llvm.ptrmask.p0.i128(ptr %ptr, i128 -8)
  %load = load <16 x i8>, ptr %aligned, align 1
  ret <16 x i8> %load
}

