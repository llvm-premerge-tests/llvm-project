; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt < %s -loop-reduce -S | FileCheck %s

; Provide legal integer types.
target datalayout = "n8:16:32:64"

define void @sdiv(i32 %0, i32 %1, ptr %2) {
; CHECK-LABEL: define void @sdiv
; CHECK-SAME: (i32 [[TMP0:%.*]], i32 [[TMP1:%.*]], ptr [[TMP2:%.*]]) {
; CHECK-NEXT:    [[TMP4:%.*]] = mul nsw i32 [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP5:%.*]] = icmp sgt i32 [[TMP4]], 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[DOTPREHEADER:%.*]], label [[TMP6:%.*]]
; CHECK:       .preheader:
; CHECK-NEXT:    br label [[TMP7:%.*]]
; CHECK:       .loopexit:
; CHECK-NEXT:    br label [[TMP6]]
; CHECK:       6:
; CHECK-NEXT:    ret void
; CHECK:       7:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[TMP4]], [[DOTPREHEADER]] ], [ [[LSR_IV_NEXT:%.*]], [[TMP7]] ]
; CHECK-NEXT:    [[DIV:%.*]] = phi i32 [ 0, [[DOTPREHEADER]] ], [ [[ADD1:%.*]], [[TMP7]] ]
; CHECK-NEXT:    [[CNT:%.*]] = phi i32 [ 0, [[DOTPREHEADER]] ], [ [[SEL:%.*]], [[TMP7]] ]
; CHECK-NEXT:    [[ICMP:%.*]] = icmp eq i32 [[CNT]], [[TMP1]]
; CHECK-NEXT:    [[ZEXT:%.*]] = zext i1 [[ICMP]] to i32
; CHECK-NEXT:    [[ADD1]] = add nsw i32 [[DIV]], [[ZEXT]]
; CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[CNT]], 1
; CHECK-NEXT:    [[SEL]] = select i1 [[ICMP]], i32 1, i32 [[ADD2]]
; CHECK-NEXT:    [[TMP8:%.*]] = sext i32 [[ADD1]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], i64 [[TMP8]]
; CHECK-NEXT:    store i32 0, ptr [[TMP9]], align 4
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i32 [[LSR_IV]], -1
; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[TMP10]], label [[DOTLOOPEXIT:%.*]], label [[TMP7]]
;
  %4 = mul nsw i32 %1, %0
  %5 = icmp sgt i32 %4, 0
  br i1 %5, label %7, label %6

6:                                                ; preds = %7, %3
  ret void

7:                                                ; preds = %7, %3
  %8 = phi i32 [ %12, %7 ], [ 0, %3 ]
  %9 = sdiv i32 %8, %1
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds i32, ptr %2, i64 %10
  store i32 0, ptr %11, align 4
  %12 = add nuw nsw i32 %8, 1
  %13 = icmp eq i32 %12, %4
  br i1 %13, label %6, label %7
}

define void @udiv(i32 %0, i32 %1, ptr %2) {
; CHECK-LABEL: define void @udiv
; CHECK-SAME: (i32 [[TMP0:%.*]], i32 [[TMP1:%.*]], ptr [[TMP2:%.*]]) {
; CHECK-NEXT:    [[TMP4:%.*]] = mul nsw i32 [[TMP1]], [[TMP0]]
; CHECK-NEXT:    [[TMP5:%.*]] = icmp sgt i32 [[TMP4]], 0
; CHECK-NEXT:    br i1 [[TMP5]], label [[DOTPREHEADER:%.*]], label [[TMP6:%.*]]
; CHECK:       .preheader:
; CHECK-NEXT:    br label [[TMP7:%.*]]
; CHECK:       .loopexit:
; CHECK-NEXT:    br label [[TMP6]]
; CHECK:       6:
; CHECK-NEXT:    ret void
; CHECK:       7:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i32 [ [[TMP4]], [[DOTPREHEADER]] ], [ [[LSR_IV_NEXT:%.*]], [[TMP7]] ]
; CHECK-NEXT:    [[DIV:%.*]] = phi i32 [ 0, [[DOTPREHEADER]] ], [ [[ADD1:%.*]], [[TMP7]] ]
; CHECK-NEXT:    [[CNT:%.*]] = phi i32 [ 0, [[DOTPREHEADER]] ], [ [[SEL:%.*]], [[TMP7]] ]
; CHECK-NEXT:    [[ICMP:%.*]] = icmp eq i32 [[CNT]], [[TMP1]]
; CHECK-NEXT:    [[ZEXT:%.*]] = zext i1 [[ICMP]] to i32
; CHECK-NEXT:    [[ADD1]] = add nuw i32 [[DIV]], [[ZEXT]]
; CHECK-NEXT:    [[ADD2:%.*]] = add nuw i32 [[CNT]], 1
; CHECK-NEXT:    [[SEL]] = select i1 [[ICMP]], i32 1, i32 [[ADD2]]
; CHECK-NEXT:    [[TMP8:%.*]] = sext i32 [[ADD1]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i32, ptr [[TMP2]], i64 [[TMP8]]
; CHECK-NEXT:    store i32 0, ptr [[TMP9]], align 4
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i32 [[LSR_IV]], -1
; CHECK-NEXT:    [[TMP10:%.*]] = icmp eq i32 [[LSR_IV_NEXT]], 0
; CHECK-NEXT:    br i1 [[TMP10]], label [[DOTLOOPEXIT:%.*]], label [[TMP7]]
;
  %4 = mul nsw i32 %1, %0
  %5 = icmp sgt i32 %4, 0
  br i1 %5, label %7, label %6

6:                                                ; preds = %7, %3
  ret void

7:                                                ; preds = %7, %3
  %8 = phi i32 [ %12, %7 ], [ 0, %3 ]
  %9 = udiv i32 %8, %1
  %10 = sext i32 %9 to i64
  %11 = getelementptr inbounds i32, ptr %2, i64 %10
  store i32 0, ptr %11, align 4
  %12 = add nuw nsw i32 %8, 1
  %13 = icmp eq i32 %12, %4
  br i1 %13, label %6, label %7
}
