; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-attributes --check-globals --version 2
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs  -S < %s | FileCheck %s --check-prefixes=CHECK,TUNIT
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s | FileCheck %s --check-prefixes=CHECK,CGSCC

%struct.Foo = type { i32, i32, i8 }

@.str = private unnamed_addr constant [15 x i8] c"Field 1 is %d\0A\00", align 1

;.
; CHECK: @[[_STR:[a-zA-Z0-9_$"\\.-]+]] = private unnamed_addr constant [15 x i8] c"Field 1 is %d\0A\00", align 1
;.
define dso_local void @foo_positive_test(i32 noundef %val) #0 {
; CHECK-LABEL: define dso_local void @foo_positive_test
; CHECK-SAME: (i32 noundef [[VAL:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VAL_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[F:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[VAL]], ptr [[VAL_ADDR]], align 4
; CHECK-NEXT:    store i32 10, ptr [[F]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[F]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 1
; CHECK-NEXT:    store i32 [[ADD]], ptr [[F]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[F]], align 4
; CHECK-NEXT:    [[ADD3:%.*]] = add nsw i32 [[TMP1]], [[VAL]]
; CHECK-NEXT:    [[CALL:%.*]] = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(15) @.str, i32 noundef [[ADD3]])
; CHECK-NEXT:    ret void
;
entry:
  %val.addr = alloca i64, align 4
  %f = alloca %struct.Foo, align 4
  store i32 %val, ptr %val.addr, align 4
  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  store i32 10, ptr %field1, align 4
  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  %0 = load i32, ptr %field11, align 4
  %add = add nsw i32 %0, 1
  store i32 %add, ptr %field11, align 4
  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  %1 = load i32, ptr %field12, align 4
  %2 = load i32, ptr %val.addr, align 4
  %add3 = add nsw i32 %1, %2
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add3)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @foo_positive_test_malloc(ptr noundef %val) #0 {
; CHECK-LABEL: define dso_local void @foo_positive_test_malloc
; CHECK-SAME: (ptr nocapture nofree noundef readonly [[VAL:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VAL_ADDR:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    [[F:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store ptr [[VAL]], ptr [[VAL_ADDR]], align 8
; CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 12)
; CHECK-NEXT:    store ptr [[CALL]], ptr [[F]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[VAL]], align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 10
; CHECK-NEXT:    store i32 [[ADD]], ptr [[CALL]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[CALL]], align 4
; CHECK-NEXT:    [[CALL2:%.*]] = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(15) @.str, i32 noundef [[TMP1]])
; CHECK-NEXT:    ret void
;
entry:
  %val.addr = alloca ptr, align 8
  %f = alloca ptr, align 8
  store ptr %val, ptr %val.addr, align 8
  %call = call noalias ptr @malloc(i64 noundef 12) #3 ;TODO The bytes allocated in this malloc should be reduced to an i32.
  store ptr %call, ptr %f, align 8
  %0 = load ptr, ptr %val.addr, align 8
  %1 = load i32, ptr %0, align 4
  %add = add nsw i32 %1, 10
  %2 = load ptr, ptr %f, align 8
  %a = getelementptr inbounds %struct.Foo, ptr %2, i32 0, i32 0
  store i32 %add, ptr %a, align 4
  %3 = load ptr, ptr %f, align 8
  %a1 = getelementptr inbounds %struct.Foo, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %a1, align 4
  %call2 = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %4)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define dso_local ptr @foo_negative_test_escaping_pointer(i32 noundef %val) #0 {
; CHECK-LABEL: define dso_local ptr @foo_negative_test_escaping_pointer
; CHECK-SAME: (i32 noundef [[VAL:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VAL_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[F:%.*]] = alloca ptr, align 8
; CHECK-NEXT:    store i32 [[VAL]], ptr [[VAL_ADDR]], align 4
; CHECK-NEXT:    [[CALL:%.*]] = call noalias ptr @malloc(i64 noundef 16)
; CHECK-NEXT:    store ptr [[CALL]], ptr [[F]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[F]], align 8
; CHECK-NEXT:    store i32 2, ptr [[TMP0]], align 8
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 10, [[VAL]]
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[F]], align 8
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 8
; CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[TMP2]], [[ADD]]
; CHECK-NEXT:    store i32 [[ADD2]], ptr [[TMP1]], align 8
; CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[F]], align 8
; CHECK-NEXT:    ret ptr [[TMP3]]
;
entry:
  %val.addr = alloca i32, align 4
  %f = alloca ptr, align 8
  store i32 %val, ptr %val.addr, align 4
  %call = call noalias ptr @malloc(i64 noundef 16) #2
  store ptr %call, ptr %f, align 8
  %0 = load ptr, ptr %f, align 8
  %field1 = getelementptr inbounds %struct.Foo, ptr %0, i32 0, i32 0
  store i32 2, ptr %field1, align 8
  %1 = load i32, ptr %val.addr, align 4
  %add = add nsw i32 10, %1
  %2 = load ptr, ptr %f, align 8
  %field11 = getelementptr inbounds %struct.Foo, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %field11, align 8
  %add2 = add nsw i32 %3, %add
  store i32 %add2, ptr %field11, align 8
  %4 = load ptr, ptr %f, align 8
  ret ptr %4
}

; Function Attrs: noinline nounwind uwtable
define dso_local { i64, ptr } @foo_negative_test_not_a_single_start_offset(i32 noundef %val) #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; CHECK-LABEL: define dso_local { i64, ptr } @foo_negative_test_not_a_single_start_offset
; CHECK-SAME: (i32 noundef [[VAL:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_FOO:%.*]], align 8
; CHECK-NEXT:    [[VAL_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[VAL]], ptr [[VAL_ADDR]], align 4
; CHECK-NEXT:    store i32 2, ptr [[RETVAL]], align 8
; CHECK-NEXT:    [[FIELD3:%.*]] = getelementptr inbounds [[STRUCT_FOO]], ptr [[RETVAL]], i32 0, i32 2
; CHECK-NEXT:    store ptr [[VAL_ADDR]], ptr [[FIELD3]], align 8
; CHECK-NEXT:    [[TMP0:%.*]] = load { i64, ptr }, ptr [[RETVAL]], align 8
; CHECK-NEXT:    ret { i64, ptr } [[TMP0]]
;
entry:
  %retval = alloca %struct.Foo, align 8
  %val.addr = alloca i32, align 4
  store i32 %val, ptr %val.addr, align 4
  %field1 = getelementptr inbounds %struct.Foo, ptr %retval, i32 0, i32 0
  store i32 2, ptr %field1, align 8
  %field3 = getelementptr inbounds %struct.Foo, ptr %retval, i32 0, i32 2
  store ptr %val.addr, ptr %field3, align 8
  %0 = load { i64, ptr }, ptr %retval, align 8
  ret { i64, ptr } %0
}

declare i32 @printf(ptr noundef, ...) #1

; Function Attrs: nounwind allocsize(0)
declare noalias ptr @malloc(i64 noundef) #1
;.
; CHECK: attributes #[[ATTR0]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
;.
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CGSCC: {{.*}}
; TUNIT: {{.*}}
