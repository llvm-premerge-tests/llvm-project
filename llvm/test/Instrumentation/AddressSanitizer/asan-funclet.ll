; Test appropriate tagging of funclet for function calls generated by asan.
; RUN: opt -S -passes=asan -asan-max-inline-poisoning-size=0 \
; RUN:   -asan-detect-invalid-pointer-cmp -asan-detect-invalid-pointer-sub -asan-use-after-scope < %s | FileCheck %s --check-prefixes=CHECK,CHECK-INLINE
; RUN: opt -S -passes=asan -asan-max-inline-poisoning-size=0 -asan-instrumentation-with-call-threshold=0  \
; RUN:   -asan-detect-invalid-pointer-cmp -asan-detect-invalid-pointer-sub -asan-use-after-scope < %s | FileCheck %s --check-prefixes=CHECK,CHECK-OUTLINE

; REQUIRES: x86-registered-target

target triple = "x86_64-pc-windows-msvc"

declare void @DeInit(ptr)
declare void @MayThrowFunc()
declare void @NoReturn() noreturn

declare void @llvm.memmove.p0.p0.i64(ptr nocapture, ptr nocapture readonly, i64, i1)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1)
declare void @llvm.lifetime.start.p0(i64, ptr nocapture) nounwind
declare void @llvm.lifetime.end.p0(i64, ptr nocapture) nounwind

declare i32 @__CxxFrameHandler3(...)
declare i32 @dummyPersonality(...)

define void @FuncletPersonality(ptr %ptrParam) sanitize_address personality ptr @__CxxFrameHandler3 {
; CHECK-LABEL: @FuncletPersonality
; CHECK: ehcleanup:
; CHECK: [[CleanupPad1:%[^ ]+]] = cleanuppad within none []
; CHECK-INLINE: call void @__asan_unpoison_stack_memory{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK-INLINE: call void @__asan_report_store1{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK-INLINE: call void @__asan_poison_stack_memory{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: call void @DeInit({{.*}}) [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: call ptr @__asan_memset{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: call ptr @__asan_memcpy{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: call ptr @__asan_memmove{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: call void @__sanitizer_ptr_cmp{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: call void @__sanitizer_ptr_sub{{.*}} [ "funclet"(token [[CleanupPad1]]) ]

; CHECK-OUTLINE: call void @__asan_storeN{{.*}} [ "funclet"(token [[CleanupPad1]]) ]

; CHECK: noreturncall:
; CHECK: call void @__asan_handle_no_return{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: ehexit:
; CHECK: call void @__asan_allocas_unpoison{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: call void @__asan_stack_free_{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
; CHECK: call void @__asan_set_shadow_{{.*}} [ "funclet"(token [[CleanupPad1]]) ]
entry:
  ; Large enough local alloca to have asan generate a __asan_stack_free_#() call
  %largeObj = alloca [2048 x i32], align 16
  %tmpInt1 = alloca i32, align 4
  %tmpInt2 = alloca i32, align 4
  %tmpInt3 = alloca i32, align 4

  ; Creating %lifetimeInt and %lifetimeArr, and managing their lifetimes
  ; to make asan generate stack poisoning calls
  %lifetimeInt = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %lifetimeInt)
  store volatile i8 0, ptr %lifetimeInt
  call void @llvm.lifetime.end.p0(i64 4, ptr %lifetimeInt)
  %lifetimeArr = alloca i32, align 4

  ; Dynamic alloca to generate a @__asan_allocas_unpoison call in ehcleanup
  %tmpVolatilei64 = alloca i64, align 8
  store volatile i64 0, ptr %tmpVolatilei64, align 8
  %tmpCopyi64 = load i64, ptr %tmpVolatilei64, align 8
  %tmpVolatilei8 = alloca i8, i64 %tmpCopyi64, align 32
  store volatile i8 0, ptr %tmpVolatilei8

  invoke void @MayThrowFunc()
          to label %invoke.cont unwind label %ehcleanup
invoke.cont:                                      ; preds = %entry
  call void @DeInit(ptr %largeObj)
  ret void

ehcleanup:                                        ; preds = %entry
  %0 = cleanuppad within none []

  ; Make asan add a call to __asan_unpoison_stack_memory
  call void @llvm.lifetime.start.p0(i64 4, ptr %lifetimeArr)
  ; Make asan add a call to __asan_report_store1
  store volatile i8 0, ptr %lifetimeArr
  ; Make asan add a call to __asan_poison_stack_memory
  call void @llvm.lifetime.end.p0(i64 4, ptr %lifetimeArr)

  call void @DeInit(ptr %largeObj) [ "funclet"(token %0) ]
  call void @llvm.memset.p0.i64(ptr align 4 %tmpInt1, i8 0, i64 4, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tmpInt2, ptr align 4 %tmpInt1, i64 4, i1 false)
  call void @llvm.memmove.p0.p0.i64(ptr align 4 %tmpInt3, ptr align 4 %tmpInt1, i64 4, i1 false)
  %cmpAddr = icmp ule ptr %tmpInt1, %tmpInt2
  %addr1 = ptrtoint ptr %tmpInt1 to i64
  %addr2 = ptrtoint ptr %tmpInt2 to i64
  %subAddr = sub i64 %addr1, %addr2

  store i64 0, ptr %ptrParam, align 1

  %cmp = icmp ne i64 %subAddr, 0
  br i1 %cmp, label %ehexit, label %noreturncall

noreturncall:
  call void @NoReturn(ptr null, ptr null) noreturn [ "funclet"(token %0) ]
  unreachable

ehexit:
  cleanupret from %0 unwind to caller

; Ensure unreachable basic block doesn't make the compiler assert, as it's a special case for coloring computation.
nopredecessor:
  call void @llvm.memset.p0.i64(ptr align 4 %tmpInt1, i8 0, i64 4, i1 false)
  unreachable
}

; Non-Windows personality, ensure no funclet gets attached to asan runtime call.
define void @OtherPersonality(ptr %ptrParam) sanitize_address personality ptr @dummyPersonality {
; CHECK-LABEL: @OtherPersonality
; CHECK: ehcleanup:
; CHECK: call ptr @__asan_memset
; CHECK-NOT: funclet
entry:
  %tmpInt = alloca i32, align 4
  invoke void @MayThrowFunc()
          to label %invoke.cont unwind label %ehcleanup
invoke.cont:                                      ; preds = %entry
  ret void

ehcleanup:                                        ; preds = %entry
  %0 = cleanuppad within none []
  call void @llvm.memset.p0.i64(ptr align 4 %tmpInt, i8 0, i64 4, i1 false)
  cleanupret from %0 unwind to caller
}
