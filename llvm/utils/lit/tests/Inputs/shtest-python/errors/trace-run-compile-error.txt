# Check that the execution trace is correct when a RUN directive fails to
# compile.  Specifically, make sure the error is written at the end of the
# execution trace and doesn't prevent stdout and stderr from prior RUN
# directives and python code from appearing.
#
# Before PYTHON directives were introduced to lit, this scenario was an
# impossible case.  There were no PYTHON directives to break RUN directives into
# multiple scripts, so all RUN directives were compiled before any were
# executed, so there could not have been prior stdout or stderr.

#    RUN: %{python} %S/../write-to-stdout-and-stderr.py
# PYTHON: import sys                                        #LN + 1
# PYTHON: print("PYTHON writes to stdout")                  #LN + 2
# PYTHON: print("PYTHON writes to stderr", file=sys.stderr) #LN + 3
#    RUN: &&

#       CHECK:Command Output (stdout):
#  CHECK-NEXT:--
#  CHECK-NEXT:$ ":" "{{RUN}}: at line [[#LN: @LINE - 8]]"
#  CHECK-NEXT:$ "{{.*/python.*}}" "{{.*}}/write-to-stdout-and-stderr.py"
#  CHECK-NEXT:# command output:
#  CHECK-NEXT:a line on stdout
# CHECK-EMPTY:
#  CHECK-NEXT:# command stderr:
#  CHECK-NEXT:a line on stderr
# CHECK-EMPTY:
#  CHECK-NEXT:# executing '{{PYTHON}}:' directive from line [[#LN + 1]] to [[#LN + 3]]
#  CHECK-NEXT:# stdout from '{{PYTHON}}:' directive from line [[#LN + 1]] to [[#LN + 3]]:
#  CHECK-NEXT:PYTHON writes to stdout
# CHECK-EMPTY:
#  CHECK-NEXT:# stderr from '{{PYTHON}}:' directive from line [[#LN + 1]] to [[#LN + 3]]:
#  CHECK-NEXT:PYTHON writes to stderr
# CHECK-EMPTY:
#  CHECK-NEXT:shell parser error on: ": 'RUN: at line [[#LN + 4]]';{{ *}}&&"
# CHECK-EMPTY:
#  CHECK-NEXT:--

# CHECK:  Unresolved: 1
