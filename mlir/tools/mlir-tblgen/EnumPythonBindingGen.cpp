//===- EnumPythonBindingGen.cpp - Generator of Python API for ODS enums ---===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// EnumPythonBindingGen uses ODS specification of MLIR enum attributes to
// generate the corresponding Python binding classes.
//
//===----------------------------------------------------------------------===//

#include "mlir/TableGen/Attribute.h"
#include "mlir/TableGen/GenInfo.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/TableGen/Record.h"

using namespace mlir;
using namespace mlir::tblgen;

/// File header and includes.
constexpr const char *fileHeader = R"Py(
# Autogenerated by mlir-tblgen; don't manually edit.

from enum import IntEnum, Enum
from ._ods_common import _cext as _ods_cext
_ods_ir = _ods_cext.ir

# Convenience decorator for (safely) registering user-friendly Attribute builders.
def _register_attribute_builder(kind):
    def decorator_builder(func):
        if not _ods_ir.AttrBuilder.contains(kind):
            _ods_ir.AttrBuilder.insert(kind, func)
        return func

    return decorator_builder

)Py";

/// Makes enum case name Python-compatible, i.e. UPPER_SNAKE_CASE.
static std::string makePythonEnumCaseName(StringRef name) {
  if (llvm::all_of(name, [](char c) {
        return std::isupper(c) || c == '_' || std::isdigit(c);
      }))
    return name.str();
  return StringRef(llvm::convertToSnakeFromCamelCase(name)).upper();
}

/// Emits the Python class for the given bit enum.
static void emitDialectEnumClass(StringRef enumName, StringRef description,
                                 ArrayRef<EnumAttrCase> cases,
                                 raw_ostream &os) {
  os << llvm::formatv("class {0}(str, Enum):\n", enumName);
  if (!description.empty())
    os << llvm::formatv("    \"\"\"{0}\"\"\"\n", description);
  os << "    def __str__(self): return self.value\n";
  os << "\n";

  for (const EnumAttrCase &enumCase : cases) {
    os << llvm::formatv("    {0} = \"{1}\"\n",
                        makePythonEnumCaseName(enumCase.getSymbol()),
                        enumCase.getStr());
  }

  os << "\n";
}

/// Emits the Python class for the given enum.
static void emitEnumClass(StringRef enumName, StringRef description,
                          ArrayRef<EnumAttrCase> cases, raw_ostream &os) {
  os << llvm::formatv("class {0}(IntEnum):\n", enumName);
  if (!description.empty())
    os << llvm::formatv("    \"\"\"{0}\"\"\"\n", description);
  os << "\n";

  for (const EnumAttrCase &enumCase : cases) {
    os << llvm::formatv("    {0} = {1}\n",
                        makePythonEnumCaseName(enumCase.getSymbol()),
                        enumCase.getValue());
  }

  os << "\n";
}

/// Attempts to extract the bitwidth B from string "uintB_t" describing the
/// type. This bitwidth information is not readily available in ODS. Returns
/// `false` on success, `true` on failure.
static bool extractUIntBitwidth(StringRef uintType, int64_t &bitwidth) {
  if (!uintType.consume_front("uint"))
    return true;
  if (!uintType.consume_back("_t"))
    return true;
  return uintType.getAsInteger(/*Radix=*/10, bitwidth);
}

/// Emits an attribute builder for the given enum attribute to support automatic
/// conversion between enum values and attributes in Python. Returns
/// `false` on success, `true` on failure.
static bool emitAttributeBuilder(StringRef attrDefName,
                                 const EnumAttr &enumAttr, raw_ostream &os) {
  int64_t bitwidth;
  if (extractUIntBitwidth(enumAttr.getUnderlyingType(), bitwidth)) {
    llvm::errs() << "failed to identify bitwidth of "
                 << enumAttr.getUnderlyingType();
    return true;
  }

  os << llvm::formatv("@_register_attribute_builder(\"{0}\")\n", attrDefName);
  os << llvm::formatv(
      "def _{0}(x, context):\n",
      llvm::convertToSnakeFromCamelCase(enumAttr.getAttrDefName()));
  os << llvm::formatv(
      "    return "
      "_ods_ir.IntegerAttr.get(_ods_ir.IntegerType.get_signless({0}, "
      "context=context), int(x))\n\n",
      bitwidth);
  return false;
}

/// Emits an attribute builder for the given bit enum attribute to support
/// automatic conversion between enum values and attributes in Python. Returns
/// `false` on success, `true` on failure.
static bool emitDialectEnumAttributeBuilder(StringRef attrDefName,
                                            StringRef formatString,
                                            raw_ostream &os) {
  os << llvm::formatv("@_register_attribute_builder(\"{0}\")\n", attrDefName);
  os << llvm::formatv("def _{0}(x, context):\n",
                      llvm::convertToSnakeFromCamelCase(attrDefName));
  os << llvm::formatv("    return "
                      "_ods_ir.Attribute.parse(f'{0}', context=context)\n\n",
                      formatString);
  return false;
}

/// Emits Python bindings for all enums in the record keeper. Returns
/// `false` on success, `true` on failure.
static bool emitPythonEnums(const llvm::RecordKeeper &recordKeeper,
                            raw_ostream &os) {
  os << fileHeader;

  // Find the records corresponding to enums with load bearing names that
  // correspond directly to op attribute names.
  llvm::DenseMap<llvm::StringRef, llvm::Record *> correctlyNamedEnums;
  for (auto &it : recordKeeper.getDefs()) {
    if (!it.second->isSubClassOf("EnumAttr") and
        !it.second->isSubClassOf("EnumAttrInfo"))
      continue;
    EnumAttr *enumAttr;
    if (it.second->isSubClassOf("EnumAttrInfo")) {
      enumAttr = new EnumAttr(*it.second);
      if (!correctlyNamedEnums.contains(enumAttr->getAttrDefName())) {
        correctlyNamedEnums[enumAttr->getAttrDefName()] = &*it.second;
      }
    } else {
      enumAttr = new EnumAttr(it.second->getValueAsDef("enum"));
      correctlyNamedEnums[enumAttr->getAttrDefName()] = &*it.second;
    }
  }

  if (correctlyNamedEnums.empty()) {
    llvm::errs() << "no enums to generate.";
    return true;
  }

  // Emit the enum classes and registration hooks with the correct names.
  for (auto &it : correctlyNamedEnums) {
    Attribute attr(it.second);
    if (it.second->isSubClassOf("EnumAttrInfo")) {
      EnumAttr enumAttr(*it.second);
      emitEnumClass(enumAttr.getEnumClassName(), enumAttr.getSummary(),
                    enumAttr.getAllCases(), os);
      emitAttributeBuilder(attr.getAttrDefName(), enumAttr, os);
    } else {
      EnumAttr enumAttr(it.second->getValueAsDef("enum"));
      emitDialectEnumClass(enumAttr.getEnumClassName(), enumAttr.getSummary(),
                           enumAttr.getAllCases(), os);
      StringRef dialect =
          attr.getDef().getValueAsDef("dialect")->getValueAsString("name");
      StringRef mnemonic = attr.getDef().getValueAsString("mnemonic");
      StringRef assemblyFormat =
          attr.getDef().getValueAsString("assemblyFormat");

      if ((assemblyFormat != "`<` $value `>`" && assemblyFormat != "$value") ||
          attr.getDef().getValueAsBit("hasCustomAssemblyFormat")) {
        llvm::errs() << "unsupported assembly format for enum";
        return true;
      }

      if (assemblyFormat == "`<` $value `>`") {
        emitDialectEnumAttributeBuilder(
            attr.getAttrDefName(),
            llvm::formatv("#{0}.{1}<{{x}>", dialect, mnemonic).str(), os);
      } else if (assemblyFormat == "$value") {
        emitDialectEnumAttributeBuilder(
            attr.getAttrDefName(),
            llvm::formatv("#{0}<{1} {{x}>", dialect, mnemonic).str(), os);
      }
    }
  }

  return false;
}

// Registers the enum utility generator to mlir-tblgen.
static mlir::GenRegistration
    genPythonEnumBindings("gen-python-enum-bindings",
                          "Generate Python bindings for enum attributes",
                          &emitPythonEnums);
