# ===----------------------------------------------------------------------===##
#
# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ===----------------------------------------------------------------------===##

import operator
import os.path

import libcxx.header_information


header_include_requirements = libcxx.header_information.header_include_requirements


always_available_headers = frozenset(
    libcxx.header_information.module_headers
).difference(*header_include_requirements.values())

libcxx_module_directory = os.path.join(
    os.path.dirname(os.path.dirname(os.path.realpath(__file__))), "modules"
)
with open(
    os.path.join(libcxx_module_directory, "std.cppm.in"), "w"
) as std_module_cpp_in:
    std_module_cpp_in.write(
        """\
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

// WARNING, this entire header is generated by
// utils/generate_std_cppm_in.py
// DO NOT MODIFY!

module;

#include <__config>

// The headers of Table 24: C++ library headers [tab:headers.cpp]
// and the headers of Table 25: C++ headers for C library facilities [tab:headers.cpp.c]
"""
    )
    # Include the angle brackets in sorting so that <a.h> sorts before <a>
    # like check-format wants.
    for include in sorted([f"<{header}>" for header in always_available_headers]):
        std_module_cpp_in.write(f"#include {include}\n")

    std_module_cpp_in.write("\n// *** Headers disabled by a feature ***\n")
    for requirements, headers in sorted(
        header_include_requirements.items(), key=operator.itemgetter(0)
    ):
        std_module_cpp_in.write("\n")
        if len(requirements) == 1:
            std_module_cpp_in.write(f"#ifndef {requirements[0]}")
        else:
            std_module_cpp_in.write("#if")
            for index, requirement in enumerate(requirements):
                if index > 0:
                    std_module_cpp_in.write(" &&")
                std_module_cpp_in.write(f" !defined({requirement})")
        std_module_cpp_in.write("\n")

        for include in sorted([f"<{header}>" for header in headers]):
            if include.endswith(".h>"):  # Skip C compatibility headers
                continue
            if (
                include == "<experimental/regex>"
            ):  # TODO MODULES remove when header this header is removed from libc++
                continue
            std_module_cpp_in.write(f"#  include {include}\n")

        std_module_cpp_in.write(f"#endif // {requirements[0]}\n")

    std_module_cpp_in.write("\n// *** Headers not yet available ***\n")
    for include in sorted(
        [f"<{header}>" for header in libcxx.header_information.headers_not_available]
    ):
        std_module_cpp_in.write(
            f"""\
# if __has_include({include})
#  error "update the header information for {include} in libcxx/utils/generate_std_cppm_in.py"
# endif //   __has_include({include})
"""
        )

    std_module_cpp_in.write(
        """
export module std;

@LIBCXX_MODULE_STD_INCLUDE_SOURCES@
"""
    )
